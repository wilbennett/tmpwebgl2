import { FSharpMap__Remove, empty, FSharpMap__Add, tryFind, ofSeq } from "../.fable/fable-library.3.0.0/Map.js";
import { comparePrimitives } from "../.fable/fable-library.3.0.0/Util.js";
import { class_type } from "../.fable/fable-library.3.0.0/Reflection.js";
import { replace as replace_1, printf, interpolate, toText } from "../.fable/fable-library.3.0.0/String.js";
import { FSharpSet__Add, FSharpSet__Contains, ofSeq as ofSeq_1 } from "../.fable/fable-library.3.0.0/Set.js";
import { replace, match } from "../.fable/fable-library.3.0.0/RegExp.js";
import { ofSeq as ofSeq_2, ofArray, iterate } from "../.fable/fable-library.3.0.0/List.js";
import { rangeNumber, getEnumerator } from "../.fable/fable-library.3.0.0/Seq.js";

export class WebglShaderUtils_ShaderSources {
    constructor() {
        this.vertexSources = ofSeq([], {
            Compare: comparePrimitives,
        });
        this.fragmentSources = ofSeq([], {
            Compare: comparePrimitives,
        });
    }
}

export function WebglShaderUtils_ShaderSources$reflection() {
    return class_type("Wil.Webgl.Core.WebglShaderUtils.ShaderSources", void 0, WebglShaderUtils_ShaderSources);
}

export function WebglShaderUtils_ShaderSources_$ctor() {
    return new WebglShaderUtils_ShaderSources();
}

export function WebglShaderUtils_ShaderSources__get_VertexSources(_) {
    return _.vertexSources;
}

export function WebglShaderUtils_ShaderSources__get_FragmentSources(_) {
    return _.fragmentSources;
}

export function WebglShaderUtils_ShaderSources__get_VertexSource_Z721C83C5(_, name) {
    const matchValue = tryFind(name, _.vertexSources);
    if (matchValue == null) {
        throw (new Error(toText(interpolate("Vertex source \u0027%P()\u0027 has not been registered", [name]))));
    }
    else {
        const source = matchValue;
        return source;
    }
}

export function WebglShaderUtils_ShaderSources__get_FragmentSource_Z721C83C5(_, name) {
    const matchValue = tryFind(name, _.fragmentSources);
    if (matchValue == null) {
        throw (new Error(toText(interpolate("Fragment source \u0027%P()\u0027 has not been registered", [name]))));
    }
    else {
        const source = matchValue;
        return source;
    }
}

export function WebglShaderUtils_ShaderSources__AddVertexSource_Z384F8060(_, name, source) {
    _.vertexSources = FSharpMap__Add(_.vertexSources, name, source);
}

export function WebglShaderUtils_ShaderSources__AddFragmentSource_Z384F8060(_, name, source) {
    _.fragmentSources = FSharpMap__Add(_.fragmentSources, name, source);
}

let WebglShaderUtils_shaderIncludes = empty();

export function WebglShaderUtils_addShaderInclude(name, text) {
    WebglShaderUtils_shaderIncludes = FSharpMap__Add(WebglShaderUtils_shaderIncludes, name, text);
}

export function WebglShaderUtils_removeShaderInclude(name) {
    WebglShaderUtils_shaderIncludes = FSharpMap__Remove(WebglShaderUtils_shaderIncludes, name);
}

export function WebglShaderUtils_getShaderInclude(name) {
    const matchValue = tryFind(name, WebglShaderUtils_shaderIncludes);
    if (matchValue == null) {
        const msg = toText(interpolate("Shader include \u0027%P()\u0027 not found", [name]));
        throw (new Error(msg));
    }
    else {
        const text = matchValue;
        return text;
    }
}

function WebglShaderUtils_processIncludes(text) {
    let replaced = ofSeq_1([], {
        Compare: comparePrimitives,
    });
    const loop = (text_1) => {
        const replaceInclude = (m) => {
            const name = m[1] || "";
            if (FSharpSet__Contains(replaced, name)) {
                return "";
            }
            else {
                replaced = FSharpSet__Add(replaced, name);
                let newText;
                const t = WebglShaderUtils_getShaderInclude(name);
                newText = ((match(t, "\r?\n$") != null) ? t : (t + "\n"));
                return loop(newText);
            }
        };
        return replace(text_1, "^#include\\s+(.+)(?:\r?\n)", replaceInclude, 2);
    };
    const replaceMultipleBlankLines = (text_2) => replace(text_2, "^(\\s*\r?\n){2,}", "\r\n", 2);
    return loop(text);
}

const WebglShaderUtils_shaderSources = WebglShaderUtils_ShaderSources_$ctor();

export function WebglShaderUtils_addVertexShaderSource(name, source) {
    WebglShaderUtils_ShaderSources__AddVertexSource_Z384F8060(WebglShaderUtils_shaderSources, name, source);
}

export function WebglShaderUtils_addFragmentShaderSource(name, source) {
    WebglShaderUtils_ShaderSources__AddFragmentSource_Z384F8060(WebglShaderUtils_shaderSources, name, source);
}

export function WebglShaderUtils_getVertexShaderSource(name) {
    const res = WebglShaderUtils_processIncludes(WebglShaderUtils_ShaderSources__get_VertexSource_Z721C83C5(WebglShaderUtils_shaderSources, name));
    return res;
}

export function WebglShaderUtils_getFragmentShaderSource(name) {
    const res = WebglShaderUtils_processIncludes(WebglShaderUtils_ShaderSources__get_FragmentSource_Z721C83C5(WebglShaderUtils_shaderSources, name));
    return res;
}

export function WebglShaderUtils_createShader(gl, typ, source) {
    const shader = gl.createShader(typ);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    if (success) {
        return shader;
    }
    else {
        let msg;
        const arg10 = gl.getShaderInfoLog(shader);
        msg = toText(printf("%s"))(arg10);
        gl.deleteShader(shader);
        const exn = new Error(msg);
        throw exn;
    }
}

function DefaultValues_addInclude(key, source) {
    WebglShaderUtils_addShaderInclude(key, source);
}

function DefaultValues_addVertex(key, source) {
    WebglShaderUtils_addVertexShaderSource(key, source);
}

function DefaultValues_addFragment(key, source) {
    WebglShaderUtils_addFragmentShaderSource(key, source);
}

iterate((tupledArg) => {
    DefaultValues_addInclude(tupledArg[0], tupledArg[1]);
}, ofArray([["precision", "\r\nprecision mediump float;"], ["out-color-fragment", "\r\nout vec4 glFragColor;"], ["init-color", "\r\n  vec4 color = v_fillColor;"], ["set-out-color", "\r\n  glFragColor = color;"], ["transparent-color", "\r\nvec4 transparent = vec4(0.0);"], ["path-params", "\r\nuniform pathParams {\r\n  vec4 strokeColor;\r\n  vec4 fillColor;\r\n  float lineWidth;\r\n};"], ["path-outvars", "\r\nflat out float v_scale;\r\nflat out float v_aliasWidth;\r\nout vec4 v_fillColor;\r\nout vec4 v_strokeColor;\r\nflat out float v_strokeWidth;"], ["path-invars", "\r\nflat in float v_scale;\r\nflat in float v_aliasWidth;\r\nin vec4 v_fillColor;\r\nin vec4 v_strokeColor;\r\nflat in float v_strokeWidth;"], ["global-ubo", "\r\nuniform global {\r\n  vec2 resolution;\r\n  vec2 mouse;\r\n  float time;\r\n  float worldScale;\r\n};"], ["camera-ubo", "\r\nuniform camera {\r\n  vec4 viewport;\r\n  mat4 projMat;\r\n  mat4 viewMat;\r\n  float zoom;\r\n};"], ["model-params", "\r\nuniform model {\r\n  mat4 modelMat;\r\n};\r\n// uniform mat4 modelMat;"], ["coordinate-conversion-vertex", "\r\n#include global-ubo\r\n#include camera-ubo\r\n#include model-params\r\n\r\nvec4 toVec4(vec2 p) { return vec4(p, 0.0, 1.0); }\r\nvec4 toVec4(vec3 p) { return vec4(p, 1.0); }\r\nvec4 modelToClip(vec2 p) { return projMat * viewMat * modelMat * toVec4(p); }\r\nvec4 modelToClip(vec3 p) { return projMat * viewMat * modelMat * vec4(p, 1.0); }\r\nvec4 modelToClip(vec4 p) { return projMat * viewMat * modelMat * p; }\r\nvec4 worldToClip(vec4 p) { return projMat * viewMat * p; }\r\nvec3 clipToNDC(vec4 p) { return p.xyz / p.w; }\r\nvec3 modelToNDC(vec2 p) { return clipToNDC(modelToClip(p)); }\r\nvec3 modelToNDC(vec3 p) { return clipToNDC(modelToClip(p)); }\r\nvec3 modelToNDC(vec4 p) { return clipToNDC(modelToClip(p)); }\r\nvec4 modelToWorld(vec2 p) { return modelMat * toVec4(p); }\r\nvec4 modelToWorld(vec3 p) { return modelMat * toVec4(p); }\r\nvec4 modelToWorld(vec4 p) { return modelMat * p; }\r\nvec4 modelToEye(vec2 p) { return viewMat * modelMat * toVec4(p); }\r\nvec4 modelToEye(vec3 p) { return viewMat * modelMat * toVec4(p); }\r\nvec4 modelToEye(vec4 p) { return viewMat * modelMat * p; }\r\n\r\nvec2 ndcToScreen(vec3 p) {\r\n  // float y = resolution.x - viewport.y;\r\n  // return (p.xy * 0.5 + 0.5) * viewport.zw + vec2(viewport.x, y);\r\n  return (p.xy * 0.5 + 0.5) * viewport.zw + viewport.xy;\r\n}\r\n\r\nvec2 modelToScreen(vec2 p) { return ndcToScreen(modelToNDC(p)); }\r\nvec2 modelToScreen(vec3 p) { return ndcToScreen(modelToNDC(p)); }\r\nvec2 modelToScreen(vec4 p) { return ndcToScreen(modelToNDC(p)); }\r\nvec2 clipToScreen(vec4 p) { return ndcToScreen(clipToNDC(p)); }\r\nvec2 worldToScreen(vec4 p) { return clipToScreen(worldToClip(p)); }\r\n  "], ["mixes", "\r\nint mix(int a, int b, float t) { return int(mix(float(a), float(b), t)); }\r\nbool mix(bool a, bool b, float t) { return bool(mix(float(a), float(b), t)); }"], ["comparisons", "\r\n// step(edge, value)\r\n//   if value \u003c edge then 0 else 1\r\n//   if value \u003e= edge then 1 else 0\r\n//\r\n//   if edge \u003e value then 0 else 1\r\n//   if edge \u003c= value then 1 else 0\r\n//\r\nfloat isGreater(float value, float base) { return 1.0 - step(value, base); }\r\nfloat isGreater(int value, int base) { return 1.0 - step(float(value), float(base)); }\r\n\r\nfloat isGreaterOrEqual(float value, float base) { return step(base, value); }\r\nfloat isGreaterOrEqual(int value, int base) { return step(float(base), float(value)); }\r\n\r\nfloat isLess(float value, float base) { return 1.0 - step(base, value); }\r\nfloat isLess(int value, int base) { return 1.0 - step(float(base), float(value)); }\r\n\r\nfloat isLessOrEqual(float value, float base) { return step(value, base); }\r\nfloat isLessOrEqual(int value, int base) { return step(float(value), float(base)); }\r\n\r\nfloat isEqual(float value, float base) { return step(base, value) * step(value, base); }\r\nfloat isEqual(int value, int base) { return step(float(base), float(value)) * step(float(value), float(base)); }"], ["conditionals", "\r\nbool boolIif[2];\r\nint intIif[2];\r\nfloat floatIif[2];\r\nvec2 vec2Iif[2];\r\nvec3 vec3Iif[2];\r\nvec4 vec4Iif[2];\r\n\r\nbool iif(bool condition, bool thenValue, bool elseValue) {\r\n  boolIif[0] = elseValue;\r\n  boolIif[1] = thenValue;\r\n  return boolIif[int(condition)];\r\n}\r\n\r\nint iif(bool condition, int thenValue, int elseValue) {\r\n intIif[0] = elseValue;\r\n  intIif[1] = thenValue;\r\n  return intIif[int(condition)];\r\n}\r\n\r\nfloat iif(bool condition, float thenValue, float elseValue) {\r\n  floatIif[0] = elseValue;\r\n  floatIif[1] = thenValue;\r\n  return floatIif[int(condition)];\r\n}\r\n\r\nvec2 iif(bool condition, vec2 thenValue, vec2 elseValue) {\r\n  vec2Iif[0] = elseValue;\r\n  vec2Iif[1] = thenValue;\r\n  return vec2Iif[int(condition)];\r\n}\r\n\r\nvec3 iif(bool condition, vec3 thenValue, vec3 elseValue) {\r\n  vec3Iif[0] = elseValue;\r\n  vec3Iif[1] = thenValue;\r\n  return vec3Iif[int(condition)];\r\n}\r\n\r\nvec4 iif(bool condition, vec4 thenValue, vec4 elseValue) {\r\n  vec4Iif[0] = elseValue;\r\n  vec4Iif[1] = thenValue;\r\n  return vec4Iif[int(condition)];\r\n}\r\n\r\nbool iif(float condition, bool thenValue, bool elseValue) {\r\n  boolIif[0] = elseValue;\r\n  boolIif[1] = thenValue;\r\n  return boolIif[int(clamp(condition, 0.0, 1.0))];\r\n}\r\n\r\nint iif(float condition, int thenValue, int elseValue) {\r\n  intIif[0] = elseValue;\r\n  intIif[1] = thenValue;\r\n  return intIif[int(clamp(condition, 0.0, 1.0))];\r\n}\r\n\r\nfloat iif(float condition, float thenValue, float elseValue) {\r\n  floatIif[0] = elseValue;\r\n  floatIif[1] = thenValue;\r\n  return floatIif[int(clamp(condition, 0.0, 1.0))];\r\n}\r\n\r\nvec2 iif(float condition, vec2 thenValue, vec2 elseValue) {\r\n  vec2Iif[0] = elseValue;\r\n  vec2Iif[1] = thenValue;\r\n  return vec2Iif[int(clamp(condition, 0.0, 1.0))];\r\n}\r\n\r\nvec3 iif(float condition, vec3 thenValue, vec3 elseValue) {\r\n  vec3Iif[0] = elseValue;\r\n  vec3Iif[1] = thenValue;\r\n  return vec3Iif[int(clamp(condition, 0.0, 1.0))];\r\n}\r\n\r\nvec4 iif(float condition, vec4 thenValue, vec4 elseValue) {\r\n  vec4Iif[0] = elseValue;\r\n  vec4Iif[1] = thenValue;\r\n  return vec4Iif[int(clamp(condition, 0.0, 1.0))];\r\n}"], ["math-consts", "\r\n// #define PI = 3.14156265358979323846\r\n// #define TWO_PI = 6.28318530718\r\nconst float PI = 3.14156265358979323846;\r\nconst float TWO_PI = 6.28318530718;\r\n  "], ["path-consts", "\r\nconst int FILL_STROKE = 1;\r\nconst int FILL_FILL = 2;\r\nconst int FILL_BORDER = 3;\r\n  "], ["quad-params", "\r\nuniform quadParams {\r\n  vec2 size;\r\n  vec4 strokeColor;\r\n  vec4 fillColor;\r\n  int fillType;\r\n  float lineWidth;\r\n  float aliasWidth;\r\n  float angle;\r\n  int instanceCount;\r\n};"], ["quad-points-strip", "\r\nvec2 quadPointsStrip[] = vec2[] (\r\n  vec2(-0.5,  0.5),\r\n  vec2(-0.5, -0.5),\r\n  vec2( 0.5,  0.5),\r\n  vec2( 0.5, -0.5)\r\n);"], ["quad-points-strip-right", "\r\nvec2 quadPointsStripRight[] = vec2[] (\r\n  vec2(0.0,  0.5),\r\n  vec2(0.0, -0.5),\r\n  vec2(1.0,  0.5),\r\n  vec2(1.0, -0.5)\r\n);"], ["quad-common", "\r\nstruct QuadParams {\r\n  vec2 screenSize;\r\n  vec2 size;\r\n  vec2 halfSize;\r\n  vec2 centerScreen;\r\n  vec2 center;\r\n  vec2 bottomLeft;\r\n  vec2 topRight;\r\n  vec2 rotation;\r\n  vec4 strokeColor;\r\n  vec4 fillColor;\r\n  int fillType;\r\n  float pixelScale;\r\n  float strokeWidth;\r\n  float aliasWidth;\r\n  int instance;\r\n  int instanceCount;\r\n};"], ["quad-outvars", "\r\n#include quad-common\r\nflat out QuadParams v_params;"], ["quad-invars", "\r\n#include quad-common\r\nflat in QuadParams v_params;"], ["calc-quad-vertexid", "\r\n  int vertexIndex = gl_VertexID % 4;"], ["calc-scaled-quad-points", "\r\n  vec2 rotation = vec2(cos(angle), sin(angle));\r\n\r\n  vec2 pointsT[] = vec2[] (\r\n    rotate(points[0] * size, rotation),\r\n    rotate(points[1] * size, rotation),\r\n    rotate(points[2] * size, rotation),\r\n    rotate(points[3] * size, rotation)\r\n  );"], ["calc-quad-dim", "\r\n  vec2 topLeft = pointsT[0];\r\n  vec2 bottomLeft = pointsT[1];\r\n  vec2 topRight = pointsT[2];\r\n  vec2 topLeftS = modelToScreen(topLeft);\r\n  vec2 bottomLeftS = modelToScreen(bottomLeft);\r\n  vec2 topRightS = modelToScreen(topRight);"], ["calc-quad-center", "\r\n  vec2 center = (bottomLeftS + topRightS) * 0.5;"], ["calc-quad-rotation", "\r\n  vec2 ab = topRightS - topLeftS;\r\n  float currentAngle = -atan(ab.y, ab.x);\r\n  rotation = vec2(cos(currentAngle), sin(currentAngle));"], ["calc-quad-vertex", "\r\n  float aliasOffsetX = mix(-aliasWidth, aliasWidth, float(vertexIndex \u003e 1));\r\n  float aliasOffsetY = mix(-aliasWidth, aliasWidth, step(float(vertexIndex % 2), 0.0));\r\n  vec2 lr = normalize(topRight - topLeft) * aliasOffsetX;\r\n  vec2 bt = normalize(topLeft - bottomLeft) * aliasOffsetY;\r\n  vec2 vertex = pointsT[vertexIndex] + lr + bt; "], ["set-quad-position", "\r\n  gl_Position = modelToClip(vertex);"], ["set-quad-params", "\r\n  vec2 size = vec2(length(topRightS - topLeftS), length(topLeftS - bottomLeftS));\r\n  float quadSize = max(size.x, size.y);\r\n  float screenSize = max(resolution.x, resolution.y);\r\n  float pixelScale = screenSize / quadSize / screenSize;\r\n\r\n  v_params.size = size;\r\n  v_params.screenSize = resolution;\r\n  v_params.halfSize = size * 0.5;\r\n  v_params.centerScreen = center;\r\n  v_params.rotation = rotation;\r\n  v_params.strokeColor = strokeColor;\r\n  v_params.fillColor = fillColor;\r\n  v_params.fillType = fillType;\r\n  v_params.pixelScale = pixelScale;\r\n  v_params.strokeWidth = lineWidth * worldScale * zoom;\r\n  v_params.aliasWidth = aliasWidth * worldScale;\r\n  v_params.instance = gl_InstanceID;\r\n  v_params.instanceCount = instanceCount;"], ["vec2", "\r\nfloat dot(vec2 v) { return dot(v, v); }\r\nvec2 perp(vec2 v) { return vec2(-v.y, v.x); }\r\nvec2 perpRight(vec2 v) { return vec2(v.y, -v.x); }\r\nfloat cross(vec2 v1, vec2 v2) { return v1.x * v2.y - v1.y * v2.x; }\r\nbool isLeftOf(vec2 v1, vec2 v2) { return cross(v1, v2) \u003c 0.0; }\r\nbool isRightOf(vec2 v1, vec2 v2) { return cross(v1, v2) \u003e 0.0; }\r\nvec2 faceToward(vec2 v1, vec2 v2) { return v1 * sign(dot(v1, v2)); }\r\n\r\nvec2 perpToward(vec2 v, vec2 toward) {\r\n  float sgn = sign(cross(toward, v));\r\n  return vec2(sgn * v.y, -sgn * v.x);\r\n}\r\n\r\nvec2 rotate(vec2 v, vec2 rotation) {\r\n  return vec2(rotation.x * v.x - rotation.y * v.y, rotation.y * v.x + rotation.x * v.y);\r\n}"], ["line-utils", "\r\n#include vec2\r\n\r\nvec2 closestLinePoint(vec2 p, vec2 normal, vec2 linePoint) {\r\n  float d = dot(normal, linePoint);  // Distance to origin.\r\n  float t = d - dot(normal, p);\r\n  return p + normal * t;\r\n}\r\n\r\nfloat distToLine(vec2 p, vec2 normal, vec2 linePoint) {\r\n  float d = dot(normal, linePoint);\r\n  return dot(normal, p) - d;\r\n}\r\n\r\nvec2 closestSegmentPoint(vec2 p, vec2 a, vec2 b) {\r\n  vec2 ab = b - a;\r\n  float t = dot(p - a, ab) / dot(ab, ab);\r\n  t = clamp(t, 0.0, 1.0);\r\n  return a + t * ab;\r\n}\r\n\r\nfloat closestSegmentTimePoint(vec2 p, vec2 a, vec2 b) {\r\n  vec2 ab = b - a;\r\n  float t = dot(p - a, ab) / dot(ab, ab);\r\n  return clamp(t, 0.0, 1.0);\r\n}\r\n\r\nfloat signedDistToSegment(vec2 p, vec2 a, vec2 b, out float t) {\r\n  vec2 ab = b - a;\r\n  vec2 ap = p - a;\r\n  vec2 normal = perp(ab);\r\n  t = dot(ap, ab) / dot(ab, ab);\r\n\r\n  if (t \u003c= 0.0) {\r\n    t = 0.0;\r\n    return length(ap);\r\n  }\r\n\r\n  if (t \u003e= 1.0) {\r\n    t = 1.0;\r\n    return length(p - b);\r\n  }\r\n\r\n  return dot(ap, normal) / dot(ab, ab);\r\n}\r\n\r\nfloat signedDistToSegment(vec2 p, vec2 a, vec2 b) {\r\n  float t;\r\n  return signedDistToSegment(p, a, b, t);\r\n}\r\n\r\nfloat sqrDistToSegment(vec2 p, vec2 a, vec2 b) {\r\n  vec2 ab = b - a;\r\n  vec2 ap = p - a;\r\n\r\n  float e = dot(ap, ab);\r\n  if (e \u003c= 0.0) return dot(ap, ap);\r\n  float f = dot(ab, ab);\r\n  \r\n  if (e \u003e= f) {\r\n    vec2 bp = p - b;\r\n    return dot(bp, bp);\r\n  }\r\n\r\n  return dot(ap, ap) - e * e / f;\r\n}\r\n\r\nfloat distToSegment(vec2 p, vec2 a, vec2 b) { return sqrt(sqrDistToSegment(p, a, b)); }\r\n\r\nvec2 rayLineIntersection(vec2 rayStart, vec2 rayDir, vec2 normal, vec2 linePoint) {\r\n  float d = dot(normal, linePoint);   // Distance to origin.\r\n  float t = (d - dot(normal, rayStart)) / dot(normal, rayDir);\r\n  return rayStart + rayDir * t;\r\n}\r\n\r\nvec2 LineLineIntersection(vec2 point1, vec2 dir1, vec2 point2, vec2 dir2) {\r\n  float t = cross(dir2, (point2 - point1)) / cross(dir2, dir1);\r\n  return point1 + dir1 * t;\r\n}"], ["sdf-consts", "\r\nconst int SDF_CUSTOM = 0;\r\nconst int SDF_LINE = 1;\r\nconst int SDF_CIRCLE = 2;\r\nconst int SDF_SQUARE = 3;\r\n  "], ["sdf-outvars", "\r\n#include quad-common\r\nflat out QuadParams v_sdfParams;"], ["sdf-invars", "\r\n#include quad-common\r\nflat in QuadParams v_sdfParams;"], ["sdf-line-outvars", "\r\n#include sdf-line-common\r\nflat out SdfLineParams v_sdfLineParams;\r\nflat out SdfLineParams v_sdfPriorLineParams;\r\nflat out SdfLineParams v_sdfNextLineParams;"], ["sdf-line-invars", "\r\n#include sdf-line-common\r\nflat in SdfLineParams v_sdfLineParams;\r\nflat in SdfLineParams v_sdfPriorLineParams;\r\nflat in SdfLineParams v_sdfNextLineParams;"], ["sdf-utils", "\r\n#include path-consts\r\n#include transparent-color\r\n#include quad-common\r\nvec2 sdfToLocalOrient(vec2 p, vec2 center, vec2 rotation) {\r\n  p = p - center;\r\n  return vec2(rotation.x * p.x - rotation.y * p.y, rotation.y * p.x + rotation.x * p.y);\r\n}\r\n\r\nvec2 sdfToLocalOrient(vec2 p, QuadParams sp) {\r\n  return sdfToLocalOrient(p, sp.center, sp.rotation);\r\n}\r\n\r\nQuadParams sdfToLocal1(QuadParams params) {\r\n  QuadParams sp = params;\r\n  float size = max(sp.size.x, sp.size.y);\r\n\r\n  // WTF: Same calculation as vertex shader but doesn\u0027t work!!!\r\n  // float quadSize = size;\r\n  // float screenSize = max(sp.screenSize.x, sp.screenSize.y);\r\n  // float strokeScale = screenSize / quadSize;\r\n  // sp.strokeWidth = sp.strokeWidth / screenSize * strokeScale;\r\n\r\n  sp.strokeWidth = sp.strokeWidth * sp.pixelScale;\r\n  sp.center = vec2(0.0);\r\n  sp.bottomLeft = vec2(-0.5);\r\n  sp.topRight = vec2(0.5);\r\n  return sp;\r\n}\r\n\r\nvec2 sdfPointToLocal1(vec2 p, QuadParams sp) {\r\n  vec2 rotation = sp.rotation;\r\n  p = p - sp.centerScreen;\r\n  p = vec2(rotation.x * p.x - rotation.y * p.y, rotation.y * p.x + rotation.x * p.y);\r\n  p /= sp.size;\r\n  return p;\r\n}\r\n\r\nfloat sdfUnion(float distance1, float distance2) { return min(distance1, distance2); }\r\nfloat sdfUnion(float d1, float d2, float d3) { return min(min(d1, d2), d3); }\r\nfloat sdfUnion(float d1, float d2, float d3, float d4) { return min(min(min(d1, d2), d3), d4); }\r\nfloat sdfDiff(float distance1, float distance2) { return max(distance1, -distance2); }\r\nfloat sdfDiff(float d1, float d2, float d3) { return max(max(d1, -d2), -d3); }\r\nfloat sdfDiff(float d1, float d2, float d3, float d4) { return max(max(max(d1, -d2), -d3), -d4); }\r\nfloat sdfIntersect(float distance1, float distance2) { return max(distance1, distance2); }\r\nfloat sdfIntersect(float d1, float d2, float d3) { return max(max(d1, d2), d3); }\r\nfloat sdfIntersect(float d1, float d2, float d3, float d4) { return max(max(max(d1, d2), d3), d4); }\r\n\r\nvec4 sdfStroke(float distance, vec4 strokeColor, float strokeWidth, float aliasWidth) {\r\n  float edgeDist = 0.0;\r\n  float strokeDist = edgeDist - strokeWidth;\r\n  float innerEdgeDist = strokeDist - aliasWidth;\r\n  float pct = smoothstep(edgeDist, aliasWidth, distance);\r\n  vec4 edgeColor = mix(strokeColor, transparent, pct);\r\n  pct = smoothstep(innerEdgeDist, strokeDist, distance);\r\n  vec4 innerEdgeColor = mix(transparent, strokeColor, pct);\r\n  vec4 color = transparent;\r\n  color = mix(color, innerEdgeColor, float(distance \u003e= innerEdgeDist));\r\n  color = mix(color, strokeColor, float(distance \u003e= strokeDist));\r\n  color = mix(color, edgeColor, float(distance \u003e edgeDist));\r\n  return color;\r\n}\r\n\r\nvec4 sdfFill(float distance, vec4 fillColor, float aliasWidth) {\r\n  float edgeDist = 0.0;\r\n  float pct = smoothstep(edgeDist, aliasWidth, distance);\r\n  vec4 edgeColor = mix(fillColor, transparent, pct);\r\n  edgeColor = mix(fillColor, vec4(0.3, 0.3, 0.3, 0.4), pct);\r\n  vec4 color = fillColor;\r\n  color = mix(color, edgeColor, float(distance \u003e= edgeDist));\r\n  // color = mix(color, transparent, float(distance \u003e edgeDist + aliasWidth));\r\n  color = mix(color, transparent, float(distance \u003e 0.0 \u0026\u0026 aliasWidth == 0.0));\r\n  return color;\r\n}\r\n\r\nvec4 sdfBorder(float distance, vec4 fillColor, vec4 strokeColor, float strokeWidth, float aliasWidth) {\r\n  float edgeDist = 0.0;\r\n  float strokeDist = edgeDist - strokeWidth;\r\n  float innerEdgeDist = strokeDist - aliasWidth;\r\n  float pct = smoothstep(edgeDist, aliasWidth, distance);\r\n  vec4 edgeColor = mix(strokeColor, transparent, pct);\r\n  pct = smoothstep(innerEdgeDist, strokeDist, distance);\r\n  vec4 innerEdgeColor = mix(fillColor, strokeColor, pct);\r\n  vec4 color = fillColor;\r\n  color = mix(color, innerEdgeColor, float(distance \u003e= innerEdgeDist));\r\n  color = mix(color, strokeColor, float(distance \u003e= strokeDist));\r\n  color = mix(color, edgeColor, float(distance \u003e edgeDist));\r\n  return color;\r\n}\r\n\r\nvec4 sdfDraw(float distance, QuadParams params) {\r\n  switch (params.fillType) {\r\n    case FILL_STROKE: return sdfStroke(distance, params.strokeColor, params.strokeWidth, params.aliasWidth);\r\n    case FILL_FILL: return sdfFill(distance, params.fillColor, params.aliasWidth);\r\n    case FILL_BORDER: return sdfBorder(distance, params.fillColor, params.strokeColor, params.strokeWidth, params.aliasWidth);\r\n    default: return transparent;\r\n  }\r\n}\r\n\r\nfloat sdfRect(vec2 p, vec2 bottomLeft, vec2 topRight) {\r\n  vec2 center = (bottomLeft + topRight) * 0.5;\r\n  vec2 extent = topRight - center;\r\n  float dist = max(abs(p.x - center.x) - extent.x, abs(p.y - center.y) - extent.y);\r\n  return dist;\r\n}\r\n\r\nfloat sdfCircle(vec2 p, vec2 center, float radius) {\r\n  float dist = length(p - center) - radius;\r\n  return dist;\r\n}\r\n\r\nfloat sdfCircle(vec2 p, float centerX, float radius) {\r\n  return sdfCircle(p, vec2(centerX, 0.0), radius);\r\n}\r\n\r\nfloat sdfCircle(vec2 p, float centerX, float centerY, float radius) {\r\n  return sdfCircle(p, vec2(centerX, centerY), radius);\r\n}\r\n  "], ["sdf-line-common", "\r\nstruct SdfLineParams {\r\n  int startCap;\r\n  int endCap;\r\n  vec2 position;\r\n  vec2 rotation;\r\n  vec2 bottomLeft;\r\n  vec2 topRight;\r\n  vec2 startBottomLeft;\r\n  vec2 endTopRight;\r\n  vec2 join1;\r\n  vec2 join2;\r\n  vec2 join3;\r\n  vec2 miterPoint;\r\n  float aliasWidth;\r\n  float hasPrior;\r\n  float hasNext;\r\n};\r\n\r\nfloat sdfRect(vec2 p, vec2 bottomLeft, vec2 topRight, bool include) {\r\n  vec2 center = (bottomLeft + topRight) * 0.5;\r\n  vec2 extent = topRight - center;\r\n  float dist = max(abs(p.x - center.x) - extent.x, abs(p.y - center.y) - extent.y);\r\n  return mix(0.00001, dist, include);\r\n}\r\n\r\nfloat sdfCircle(vec2 p, vec2 center, float radius, bool include) {\r\n  float dist = length(p - center) - radius;\r\n  return mix(0.00001, dist, include);\r\n}\r\n\r\nfloat sdfCircle(vec2 p, float centerX, float radius, bool include) {\r\n  return sdfCircle(p, vec2(centerX, 0.0), radius, include);\r\n}\r\n\r\nfloat sdfCircle(vec2 p, float centerX, float centerY, float radius, bool include) {\r\n  return sdfCircle(p, vec2(centerX, centerY), radius, include);\r\n}\r\n  "], ["sdf-line-utils", "\r\nstruct SdfLineValues {\r\n  int startCap;\r\n  int endCap;\r\n  vec2 position;\r\n  vec2 rotation;\r\n  vec2 startBottomLeft;\r\n  vec2 endTopRight;\r\n  vec2 bottomLeft;\r\n  vec2 topRight;\r\n  vec2 b;\r\n  vec2 d;\r\n  vec2 e;\r\n  vec2 miterPoint;\r\n  float radius;\r\n};\r\n\r\nfloat sdfSegment(vec2 p, SdfLineValues values) {\r\n  return sdfRect(p, values.bottomLeft, values.topRight, true);\r\n}\r\n\r\nfloat sdfSegmentLeftSquare(vec2 p, SdfLineValues values, bool include) {\r\n  return sdfRect(p, values.startBottomLeft, values.topRight, include);\r\n}\r\n\r\nfloat sdfSegmentRightSquare(vec2 p, SdfLineValues values, bool include) {\r\n  return sdfRect(p, values.bottomLeft, values.endTopRight, include);\r\n}\r\n\r\nfloat sdfSegmentLeftRound(vec2 p, SdfLineValues values, bool include) {\r\n  return sdfCircle(p, values.bottomLeft.x, values.radius, include);\r\n}\r\n\r\nfloat sdfSegmentRightRound(vec2 p, SdfLineValues values, bool include) {\r\n  return sdfCircle(p, values.topRight.x, values.radius, include);\r\n}\r\n  "], ["sdf-linepath-fragment", "\r\n#include line-consts\r\n#include vec2\r\n#include sdf-utils\r\n#include sdf-line-utils\r\n\r\nSdfLineValues sdfLinePathValues(SdfLineParams params) {\r\n  SdfLineValues result;\r\n  vec2 pos = params.position;\r\n  vec2 rot = params.rotation;\r\n  result.startCap = params.startCap;\r\n  result.endCap = params.endCap;\r\n  result.position = pos;\r\n  result.rotation = rot;\r\n  result.startBottomLeft = sdfToLocalOrient(params.startBottomLeft, pos, rot);\r\n  result.endTopRight = sdfToLocalOrient(params.endTopRight, pos, rot);\r\n  result.bottomLeft = sdfToLocalOrient(params.bottomLeft, pos, rot);\r\n  result.topRight = sdfToLocalOrient(params.topRight, pos, rot);\r\n  result.b = sdfToLocalOrient(params.join1, pos, rot);\r\n  result.d = sdfToLocalOrient(params.join2, pos, rot);\r\n  result.e = sdfToLocalOrient(params.join3, pos, rot);\r\n  result.miterPoint = sdfToLocalOrient(params.miterPoint, pos, rot);\r\n  result.radius = abs(result.bottomLeft.x - result.startBottomLeft.x);\r\n  return result;\r\n}\r\n\r\nfloat sdfSegmentJoinBevel(vec2 p, SdfLineValues values, bool include) {\r\n  vec2 b = values.b;\r\n  vec2 d = values.d;\r\n  vec2 e = values.e;\r\n\r\n  float s1 = cross(p - b, (d - b));          // Positive if bp is right of bd, negative if left.\r\n  float s2 = cross(p - d, normalize(e - d)); // Normalize to reduce aliasing.\r\n  float s3 = cross(p - e, (b - e));\r\n  float square = sdfSegmentRightSquare(p, values, include);\r\n\r\n  float dist = sdfIntersect(s1, s2, s3, square);\r\n  return mix(0.00001, dist, include);\r\n}\r\n\r\nfloat sdfSegmentJoinMiter(vec2 p, SdfLineValues values, bool include) {\r\n  vec2 b = values.b;\r\n  vec2 d = values.d;\r\n  vec2 e = values.e;\r\n  vec2 m = values.miterPoint;\r\n\r\n  float s1 = cross(p - b, (d - b));\r\n  float s2 = cross(p - d, normalize(m - d)); // Normalize outer edges to reduce aliasing.\r\n  float s3 = cross(p - m, normalize(e - m));\r\n  float s4 = cross(p - e, (b - e));\r\n  float dist = sdfIntersect(s1, s2, s3, s4);\r\n  return mix(0.00001, dist, include);\r\n}\r\n\r\nfloat sdfLinePath(vec2 p, SdfLineValues values) {\r\n  float startCap =\r\n    sdfSegmentLeftSquare(p, values, values.startCap == CAP_SQUARE) +\r\n    sdfSegmentLeftRound(p, values, values.startCap == CAP_ROUND);\r\n\r\n  float endCap =\r\n    sdfSegmentRightRound(p, values, values.endCap == CAP_ROUND) +\r\n    sdfSegmentRightSquare(p, values, values.endCap == CAP_SQUARE) +\r\n    sdfSegmentJoinBevel(p, values, values.endCap == JOIN_BEVEL) +\r\n    sdfSegmentJoinMiter(p, values, values.endCap == JOIN_MITER) +\r\n    sdfSegmentRightRound(p, values, values.endCap == JOIN_ROUND);\r\n  \r\n  startCap = mix(startCap, 10.0, startCap == 0.00002);\r\n  endCap = mix(endCap, 10.0, endCap == 0.00005);\r\n  return sdfUnion(sdfSegment(p, values), startCap, endCap);\r\n}\r\n\r\nvec4 sdfDrawLinePath(SdfLineParams lineParams, SdfLineParams priorParams, SdfLineParams nextParams, vec4 color, float aliasWidth) {\r\n  SdfLineValues values = sdfLinePathValues(lineParams);\r\n  vec2 p = sdfToLocalOrient(gl_FragCoord.xy, values.position, values.rotation);\r\n  float line = sdfLinePath(p, values);\r\n\r\n  values = sdfLinePathValues(priorParams);\r\n  p = sdfToLocalOrient(gl_FragCoord.xy, values.position, values.rotation);\r\n  float prior = sdfLinePath(p, values);\r\n  float priorIntersect = sdfIntersect(line, prior);\r\n  priorIntersect = mix(10.0, priorIntersect, lineParams.hasPrior == 1.0);\r\n\r\n  values = sdfLinePathValues(nextParams);\r\n  p = sdfToLocalOrient(gl_FragCoord.xy, values.position, values.rotation);\r\n  float next = sdfSegment(p, values);\r\n  float intersect = sdfIntersect(line, next);\r\n  intersect = mix(10.0, sdfIntersect(line, next), lineParams.hasNext == 1.0);\r\n  line = mix(line, sdfDiff(line, next), lineParams.hasNext == 1.0);\r\n\r\n  intersect = min(intersect, priorIntersect);\r\n  aliasWidth = mix(aliasWidth, 0.0, intersect \u003c= line);\r\n  return sdfFill(line, color, aliasWidth);\r\n}\r\n  "], ["circle-outvars", "\r\nflat out float v_isCircle;\r\nflat out float v_isSemicircle;\r\nflat out float v_isWedge;\r\nflat out vec2 v_circleCenter;\r\nflat out vec2 v_radiusDirection;\r\nflat out float v_wedgeCrossLimit;"], ["circle-invars", "\r\nflat in float v_isCircle;\r\nflat in float v_isSemicircle;\r\nflat in float v_isWedge;\r\nflat in vec2 v_circleCenter;\r\nflat in vec2 v_radiusDirection;\r\nflat in float v_wedgeCrossLimit;"], ["plots-fragment", "\r\nfloat plotPct(float targetY, float y, float width) {\r\n  return step(abs(targetY - y), width);\r\n}\r\n\r\nfloat smoothPlotPct(float targetY, float y, float width) {\r\n  return smoothstep(targetY - width, targetY, y) - smoothstep(targetY, targetY + width,  y);\r\n}\r\n\r\nfloat innerEdge(in float radius, in float width, in float dist) {\r\n  return step(radius - width, dist);\r\n}\r\n\r\nfloat smoothEdge(in float radius, in float width, in float dist) {\r\n  return smoothstep(radius - width, radius + width, dist);\r\n}\r\n\r\nfloat smoothInnerEdge(in float radius, in float width, in float dist) {\r\n  return smoothstep(radius - width, radius, dist);\r\n}\r\n\r\nfloat smoothOuterEdge(in float radius, in float width, in float dist) {\r\n  return smoothstep(radius, radius + width, dist);\r\n}"], ["circles-fragment", "\r\n#include transparent-color\r\n#include plots-fragment\r\n#include conditionals\r\n#include vec2\r\n#line 328\r\nfloat circleDist(in vec2 center, in float radius, in vec2 p){\r\n  // vec2 cp = p - center;\r\n\t// return dot(cp, cp) * 4.0;\r\n  return distance(p, center);\r\n}\r\n\r\nvec4 semicircle(vec2 center, vec2 radiusDirection, vec4 fillColor, vec2 p) {\r\n  float radius = length(radiusDirection);\r\n  vec2 fragDirection = p - center;\r\n  float dist = length(fragDirection);\r\n  float delta = fwidth(dist);\r\n  float pct = smoothEdge(radius, delta, dist);\r\n  vec4 color = mix(fillColor, transparent, pct);\r\n  vec4 innerColor = iif(dist \u003c= radius, fillColor, transparent);\r\n  float dotDR = dot(fragDirection, radiusDirection);\r\n  return iif(dist \u003c (radius - delta), innerColor, color);\r\n}\r\n\r\nvec4 wedge(vec2 center, vec2 radiusDirection, float wedgeCrossLimit, vec4 fillColor, vec2 p) {\r\n  float radius = length(radiusDirection);\r\n  vec2 fragDirection = p - center;\r\n  float wedgeCross = abs(cross(normalize(fragDirection), normalize(radiusDirection)));\r\n  float dist = length(fragDirection);\r\n  float delta = fwidth(dist);\r\n  float pct = smoothEdge(radius, delta, dist);\r\n  vec4 color = mix(fillColor, transparent, pct);\r\n  vec4 innerColor = iif(dist \u003c= radius, fillColor, transparent);\r\n  bool isInCircle = dist \u003c= radius;\r\n  bool isInSemiCircle = isInCircle \u0026\u0026 dot(fragDirection, radiusDirection) \u003e= 0.0;\r\n  bool isInWedge = isInSemiCircle \u0026\u0026 wedgeCross \u003c= wedgeCrossLimit;\r\n  // bool isOnSide = isInWedge \u0026\u0026 abs(wedgeCross - wedgeCrossLimit) \u003c= 0.01;\r\n  color = iif(isInSemiCircle \u0026\u0026 isInWedge, color, transparent);\r\n  color = iif(dist \u003c (radius - delta), innerColor, color);\r\n  // TODO: Smooth sides.\r\n  return color;\r\n}\r\n\r\nvec4 circle(vec2 center, float radius, vec4 fillColor, vec2 p) {\r\n  float dist = circleDist(center, radius, p);\r\n  float pct = smoothEdge(radius, fwidth(dist), dist);\r\n  return mix(fillColor, transparent, pct);\r\n}\r\n\r\nvec4 circle(vec2 center, float radius, float strokeWidth, vec4 fillColor, vec4 strokeColor, vec2 p) {\r\n  vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\r\n  float bw = max(strokeWidth, 0.0001);\r\n  float dist = circleDist(center, radius, p);\r\n  float fillPct = innerEdge(radius, bw, dist);\r\n  float bmult = step(radius, dist);\r\n  vec4 fill = mix(fillColor, strokeColor, fillPct);\r\n  return mix(fill, transparent, bmult);\r\n}\r\n\r\nvec4 smoothCircle(vec2 center, float radius, float strokeWidth, vec4 fillColor, vec4 strokeColor, vec2 p) {\r\n  vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\r\n  float bw = max(strokeWidth, 0.0001);\r\n  float iw = bw * 0.01;\r\n  float ow = bw * 0.02;\r\n  float ir = radius - bw + iw;\r\n  float or = radius - ow;\r\n  float dist = circleDist(center, radius, p);\r\n  float fillPct = smoothInnerEdge(ir, iw, dist);\r\n  float bordPct = smoothOuterEdge(or, ow, dist);\r\n  vec4 fill = mix(fillColor, strokeColor, fillPct);\r\n  vec4 bord = mix(strokeColor, transparent, bordPct);\r\n  float bmult = 1.0 - step(bordPct, 0.0);\r\n  return mix(fill, bord, bmult);\r\n}"], ["circle-color-fragment", "\r\n  vec4 circleColor = circle(v_circleCenter, length(v_radiusDirection), v_fillColor, gl_FragCoord.xy);\r\n  color = iif(v_isCircle, circleColor, color);"], ["circle-color-discard-fragment", "\r\n  vec4 circleColor = circle(v_circleCenter, length(v_radiusDirection), v_fillColor, gl_FragCoord.xy);\r\n  if (v_isCircle == 1.0 \u0026\u0026 circleColor == transparent) discard;\r\n  color = iif(v_isCircle, circleColor, color);"], ["semicircle-color-fragment", "\r\n  vec4 semicircleColor = semicircle(v_circleCenter, v_radiusDirection, v_fillColor, gl_FragCoord.xy);\r\n  color = iif(v_isSemicircle, semicircleColor, color);"], ["semicircle-color-discard-fragment", "\r\n  vec4 semicircleColor = semicircle(v_circleCenter, v_radiusDirection, v_fillColor, gl_FragCoord.xy);\r\n  if (v_isSemicircle == 1.0 \u0026\u0026 semicircleColor == transparent) discard;\r\n  color = iif(v_isSemicircle, semicircleColor, color);"], ["wedge-color-fragment", "\r\n  vec4 wedgeColor = wedge(v_circleCenter, v_radiusDirection, v_wedgeCrossLimit, v_fillColor, gl_FragCoord.xy);\r\n  color = iif(v_isWedge, wedgeColor, color);"], ["wedge-color-discard-fragment", "\r\n  vec4 wedgeColor = wedge(v_circleCenter, v_radiusDirection, v_wedgeCrossLimit, v_fillColor, gl_FragCoord.xy);\r\n  if (v_isWedge == 1.0 \u0026\u0026 wedgeColor == transparent) discard;\r\n  color = iif(v_isWedge, wedgeColor, color);"], ["line-consts", "\r\nconst int CAP_BUTT = 0;\r\nconst int CAP_ROUND = 1;\r\nconst int CAP_SQUARE = 2;\r\nconst int JOIN_ROUND = 3;\r\nconst int JOIN_BEVEL = 4;\r\nconst int JOIN_MITER = 5;"], ["lines2d-vertex", "\r\n#include line-consts\r\n#include coordinate-conversion-vertex\r\n#include conditionals\r\n#include vec2\r\n#line 433\r\n\r\nconst int CAP_LINE = 6;\r\n\r\nconst vec2 emptyVertex = vec2(0.0);\r\n\r\nbool capFlags[] = bool[7](false, false, false, false, false, false, false);\r\nvec2 tp[3];\r\n\r\nconst vec2 lineTemplate[] = vec2[18](\r\n  // Start\r\n  vec2(0.5, -0.5),\r\n  vec2(0.0, -0.5),\r\n  vec2(0.5,  0.5),\r\n\r\n  vec2(0.0, -0.5),\r\n  vec2(0.0,  0.5),\r\n  vec2(0.5,  0.5),\r\n\r\n  // Line\r\n  vec2(0.0, -0.5),\r\n  vec2(1.0, -0.5),\r\n  vec2(0.0,  0.5),\r\n\r\n  vec2(1.0, -0.5),\r\n  vec2(1.0,  0.5),\r\n  vec2(0.0,  0.5),\r\n\r\n  // End\r\n  vec2(0.0, -0.5),\r\n  vec2(0.5, -0.5),\r\n  vec2(0.0,  0.5),\r\n\r\n  vec2(0.5, -0.5),\r\n  vec2(0.5,  0.5),\r\n  vec2(0.0,  0.5)\r\n);\r\n\r\nvoid setCapFlag(int cap, bool value) {\r\n  capFlags[CAP_BUTT] = false;\r\n  capFlags[CAP_SQUARE] = false;\r\n  capFlags[CAP_ROUND] = false;\r\n  capFlags[JOIN_ROUND] = false;\r\n  capFlags[JOIN_BEVEL] = false;\r\n  capFlags[JOIN_MITER] = false;\r\n  capFlags[CAP_LINE] = false;\r\n  capFlags[cap] = value;\r\n}\r\n\r\nvec2 addSquareCap(vec2 point, vec2 direction, vec2 leftNormal, float lineWidth, int vertexIndex) {\r\n  vec2 offset = lineTemplate[vertexIndex];\r\n  vec2 vertex = point + direction * (lineWidth * offset.x) + leftNormal * (lineWidth * offset.y);\r\n  return iif(capFlags[CAP_SQUARE], vertex, emptyVertex);\r\n}\r\n\r\nvec2 addRoundCap(vec2 point, vec2 direction, vec2 leftNormal, float lineWidth, int vertexIndex, inout float isSemicircle, inout vec2 center, inout vec2 radiusDir) {\r\n  bool isActive = capFlags[CAP_ROUND];\r\n\r\n  vec2 sCircleEdge = modelToScreen(point + direction * (lineWidth * 0.5));\r\n  isSemicircle = iif(isActive, 1.0, isSemicircle);\r\n  center = iif(isActive, modelToScreen(point), center);\r\n  radiusDir = iif(isActive, sCircleEdge - center, radiusDir);\r\n\r\n  vec2 offset = lineTemplate[vertexIndex];\r\n  vec2 vertex = point + direction * (lineWidth * offset.x) + leftNormal * (lineWidth * offset.y);\r\n  return iif(isActive, vertex, emptyVertex);\r\n}\r\n\r\nvoid joinCommon(vec2 a, vec2 b, vec2 c, vec2 ab, float lineWidth, out vec2 d, out vec2 e, out vec2 bd, out vec2 be) {\r\n  float halfLineWidth = lineWidth * 0.5;\r\n  vec2 cb = b - c;\r\n  vec2 abDirection = normalize(ab);\r\n  vec2 joinDirection = ab + cb;\r\n  vec2 abNormal = perpToward(abDirection, joinDirection);\r\n  vec2 cbNormal = perpToward(normalize(cb), joinDirection);\r\n  vec2 p1 = b + abNormal * halfLineWidth;\r\n  vec2 p2 = b + cbNormal * halfLineWidth;\r\n  vec2 b1 = p1 - b;\r\n  vec2 b2 = p2 - b;\r\n  // Make sure correct winding in case face culling is enabled.\r\n  bool p2IsRight = isRightOf(b2, b1);\r\n  d = iif(p2IsRight, p2, p1);\r\n  e = iif(p2IsRight, p1, p2);\r\n  bd = iif(p2IsRight, b2, b1);\r\n  be = iif(p2IsRight, b1, b2);\r\n}\r\n\r\nvec2 addRoundJoin(vec2 a, vec2 b, vec2 c, vec2 ab, vec2 leftNormal, float lineWidth, int vertexIndex, inout float isWedge, inout vec2 center, inout vec2 radiusDir, inout float wedgeCrossLimit) {\r\n  int vertexID = vertexIndex % 6;\r\n  bool isActive = capFlags[JOIN_ROUND];\r\n\r\n  vec2 d;\r\n  vec2 e;\r\n  vec2 bd;\r\n  vec2 be;\r\n  joinCommon(a, b, c, ab, lineWidth, d, e, bd, be);\r\n  vec2 circleEdge = b + normalize(bd + be) * (lineWidth * 0.5);\r\n\r\n  vec2 sD = modelToScreen(d);\r\n  vec2 sCircleEdge = modelToScreen(circleEdge);\r\n  // WEIRD:  Is this a bug in GLSL? radiusDir is not set correctly!!! (capFlags as float).\r\n  // isWedge = mix(isWedge, 1.0, isActive);\r\n  // center = mix(center, modelToScreen(b), isActive);\r\n  // radiusDir = mix(radiusDir, sCircleEdge - center, isActive);\r\n  // wedgeCrossLimit = mix(wedgeCrossLimit, cross(normalize(sD - center), radiusDir), isActive);\r\n\r\n  isWedge = iif(isActive, 1.0, isWedge);\r\n  center = iif(isActive, modelToScreen(b), center);\r\n  radiusDir = iif(isActive, sCircleEdge - center, radiusDir);\r\n  wedgeCrossLimit = iif(isActive, cross(normalize(sD - center), normalize(radiusDir)), wedgeCrossLimit);\r\n\r\n  vec2 offset = lineTemplate[vertexIndex];\r\n  vec2 vertex = b + ab * (lineWidth * offset.x) + leftNormal * (lineWidth * offset.y);\r\n  return iif(isActive, vertex, emptyVertex);\r\n}\r\n\r\nvec2 addBevel(vec2 a, vec2 b, vec2 c, vec2 ab, float lineWidth, int vertexIndex) {\r\n  int vertexID = vertexIndex % 6;\r\n  int id = vertexID % 3;         // Vertex index for the current triangle.\r\n\r\n  vec2 d;\r\n  vec2 e;\r\n  vec2 bd;\r\n  vec2 be;\r\n  joinCommon(a, b, c, ab, lineWidth, d, e, bd, be);\r\n\r\n  tp[0] = b;\r\n  tp[1] = d;\r\n  tp[2] = e;\r\n  return iif(capFlags[JOIN_BEVEL] \u0026\u0026 vertexID \u003c 3, tp[id], emptyVertex); // Only using first triangle.\r\n}\r\n\r\nvec2 addMiter(vec2 a, vec2 b, vec2 c, vec2 ab, float lineWidth, float miterLimit, int miterFallback, int vertexIndex) {\r\n  int vertexID = vertexIndex % 6;\r\n  int id = vertexID % 3;         // Vertex index for the current triangle.\r\n  float isFirstTriangle = float(vertexID \u003c 3);\r\n\r\n  vec2 d;\r\n  vec2 e;\r\n  vec2 bd;\r\n  vec2 be;\r\n  joinCommon(a, b, c, ab, lineWidth, d, e, bd, be);\r\n  vec2 miter = normalize(bd + be);\r\n\r\n  // Find the intersection of miter and the segment (2D sdfPlane) going through d.\r\n  vec2 normal = normalize(bd); // Normal to the sdfPlane.\r\n  float nd = dot(normal, d);   // Distance to origin.\r\n  float t = (nd - dot(normal, b)) / dot(normal, miter);\r\n  vec2 miterPoint = b + miter * t;\r\n\r\n  bool useFallback = t \u003e miterLimit;\r\n  capFlags[miterFallback] = capFlags[miterFallback] || (useFallback \u0026\u0026 capFlags[JOIN_MITER]);\r\n  capFlags[JOIN_MITER] = capFlags[JOIN_MITER] \u0026\u0026 !useFallback;\r\n\r\n  tp[0] = b;\r\n  tp[1] = iif(isFirstTriangle, d, miterPoint);\r\n  tp[2] = iif(isFirstTriangle, miterPoint, e);\r\n\r\n  // BUG: Another weird case. Does not work correctly. 0.0 should return vec2(0.0) and 1.0 the original.\r\n  // Using mix doesn\u0027t work either.\r\n  // return tp[id] * vec2(capFlags[JOIN_MITER]);\r\n\r\n  return iif(capFlags[JOIN_MITER], tp[id], emptyVertex);\r\n}\r\n\r\nvec2 addCap(int cap, vec2 point, vec2 direction, vec2 leftNormal, float lineWidth, int vertexIndex, inout float isSemicircle, inout vec2 center, inout vec2 radiusDir) {\r\n  return addSquareCap(point, direction, leftNormal, lineWidth, vertexIndex)\r\n    + addRoundCap(point, direction, leftNormal, lineWidth, vertexIndex, isSemicircle, center, radiusDir);\r\n}\r\n\r\nvec2 addCap(int cap, float miterLimit, int miterFallback, vec2 point, vec2 a, vec2 b, vec2 c, vec2 direction, vec2 leftNormal, float lineWidth, int vertexIndex, inout float isSemicircle, inout float isWedge, inout vec2 center, inout vec2 radiusDir, inout float wedgeCrossLimit) {\r\n  return addMiter(a, b, c, direction, lineWidth, miterLimit, miterFallback, vertexIndex)\r\n    + addSquareCap(point, direction, leftNormal, lineWidth, vertexIndex)\r\n    + addRoundCap(point, direction, leftNormal, lineWidth, vertexIndex, isSemicircle, center, radiusDir)\r\n    + addRoundJoin(a, b, c, direction, leftNormal, lineWidth, vertexIndex, isWedge, center, radiusDir, wedgeCrossLimit)\r\n    + addBevel(a, b, c, direction, lineWidth, vertexIndex);\r\n}\r\n\r\nvec2 line2d(vec2 a, vec2 direction, vec2 leftNormal, float lineWidth, int vertexID) {\r\n  vec2 offset = lineTemplate[vertexID + 6];\r\n  return a + direction * offset.x + leftNormal * (lineWidth * offset.y);\r\n}\r\n\r\nvec2 _line2d(vec2 a, vec2 direction, vec2 leftNormal, float lineWidth, int vertexID) {\r\n  vec2 vertex = line2d(a, direction, leftNormal, lineWidth, vertexID);\r\n  return iif(capFlags[CAP_LINE], vertex, emptyVertex);\r\n}\r\n\r\nvec2 line2d(vec2 a, vec2 b, float lineWidth, int cap, int vertexIndex, inout float isSemicircle, inout vec2 center, inout vec2 radiusDir) {\r\n  int section = vertexIndex / 6;\r\n  int vertexID = vertexIndex % 6;\r\n\r\n  vec2 direction = b - a;\r\n  vec2 normalizedDirection = normalize(direction);\r\n  vec2 leftNormal = perp(normalizedDirection);\r\n  setCapFlag(cap, section == 0);\r\n  vec2 startVertex = addCap(cap, a, -normalizedDirection, leftNormal, lineWidth, vertexIndex, isSemicircle, center, radiusDir);\r\n  setCapFlag(CAP_LINE, section == 1);\r\n  vec2 lineVertex = _line2d(a, direction, leftNormal, lineWidth, vertexID);\r\n  setCapFlag(cap, section == 2);\r\n  vec2 endVertex = addCap(cap, b, normalizedDirection, leftNormal, lineWidth, vertexIndex, isSemicircle, center, radiusDir);\r\n  return startVertex + lineVertex + endVertex;\r\n}\r\n\r\nvec3 linepath2d(vec2 a, vec2 b, vec2 c, float lineWidth, int lineCap, int lineJoin, float miterLimit, int miterFallback, int instance, int instanceCount, int vertexIndex, inout float isSemicircle, inout float isWedge, inout vec2 center, inout vec2 radiusDir, inout float wedgeCrossLimit) {\r\n  int section = vertexIndex / 6;\r\n  int vertexID = vertexIndex % 6;\r\n\r\n  int startCap = int(mix(float(CAP_BUTT), float(lineCap), float(instance == 0)));\r\n  int endCap = int(mix(float(lineJoin), float(lineCap), float(instance == instanceCount - 1)));\r\n  // endCap = int(mix(float(lineCap), float(lineCap), float(instance == instanceCount - 1)));\r\n\r\n  vec2 direction = b - a;\r\n  vec2 normalizedDirection = normalize(direction);\r\n  vec2 leftNormal = perp(normalizedDirection);\r\n  setCapFlag(startCap, section == 0);\r\n  vec2 startVertex = addCap(startCap, miterLimit, miterFallback, a, a, b, c, -normalizedDirection, leftNormal, lineWidth, vertexIndex, isSemicircle, isWedge, center, radiusDir, wedgeCrossLimit);\r\n  setCapFlag(CAP_LINE, section == 1);\r\n  vec2 lineVertex = _line2d(a, direction, leftNormal, lineWidth, vertexID);\r\n  setCapFlag(endCap, section == 2);\r\n  vec2 endVertex = addCap(endCap, miterLimit, miterFallback, b, a, b, c, normalizedDirection, leftNormal, lineWidth, vertexIndex, isSemicircle, isWedge, center, radiusDir, wedgeCrossLimit);\r\n  vec2 vertex = startVertex + lineVertex + endVertex;\r\n  return vec3(vertex, float(instanceCount - instance) * 0.00001);\r\n}"], ["lines2d2-vertex", "\r\n#include line-consts\r\n#include coordinate-conversion-vertex\r\n#include conditionals\r\n#include vec2\r\n#include line-utils\r\n#line 679\r\n\r\nconst int CAP_LINE = 6;\r\nint section;\r\n\r\nconst vec2 emptyVertex = vec2(0.0);\r\n\r\nbool capFlags[] = bool[7](false, false, false, false, false, false, false);\r\nvec2 tp[4];\r\n\r\nconst vec2 lineTemplate[] = vec2[11](\r\n  // Start\r\n  vec2(0.5, -0.5),\r\n  vec2(0.0, -0.5),\r\n  vec2(0.5,  0.5),\r\n  vec2(0.0,  0.5),\r\n\r\n  // Line\r\n  vec2(0.0,  0.5),\r\n  vec2(0.0, -0.5),\r\n  vec2(1.0,  0.5),\r\n  vec2(1.0, -0.5),\r\n\r\n  // End\r\n  vec2(0.5,  0.5),\r\n  vec2(0.5, -0.5),\r\n  vec2(0.5, -0.5)\r\n);\r\n\r\n// vec2 texCoords[] = vec2[18] (\r\n// );\r\n\r\nvoid setCapFlag(int cap, bool value) {\r\n  capFlags[CAP_BUTT] = false;\r\n  capFlags[CAP_SQUARE] = false;\r\n  capFlags[CAP_ROUND] = false;\r\n  capFlags[JOIN_ROUND] = false;\r\n  capFlags[JOIN_BEVEL] = false;\r\n  capFlags[JOIN_MITER] = false;\r\n  capFlags[CAP_LINE] = false;\r\n  capFlags[cap] = value;\r\n}\r\n\r\nvec2 addVerticies(bool flag, vec2 offset, vec2 point, vec2 direction, vec2 leftNormal, float lineWidth, int vertexIndex) {\r\n  vec2 vertex = point + direction * (lineWidth * offset.x) + leftNormal * (lineWidth * offset.y);\r\n  return iif(flag, vertex, emptyVertex);\r\n}\r\n\r\nvec2 processRoundCap(vec2 point, vec2 direction, vec2 leftNormal, float lineWidth, int vertexIndex, inout float isSemicircle, inout vec2 center, inout vec2 radiusDir) {\r\n  bool isActive = capFlags[CAP_ROUND];\r\n\r\n  vec2 sCircleEdge = modelToScreen(point + direction * (lineWidth * 0.5));\r\n  isSemicircle = iif(isActive, 1.0, isSemicircle);\r\n  center = iif(isActive, modelToScreen(point), center);\r\n  radiusDir = iif(isActive, sCircleEdge - center, radiusDir);\r\n  return emptyVertex;\r\n}\r\n\r\nvoid joinCommon(vec2 a, vec2 b, vec2 c, vec2 ab, float lineWidth, out vec2 d, out vec2 e, out vec2 bd, out vec2 be, out vec2 miter) {\r\n  float halfLineWidth = lineWidth * 0.5;\r\n  vec2 cb = b - c;\r\n  vec2 abDirection = normalize(ab);\r\n  vec2 joinDirection = ab + cb;\r\n  vec2 abNormal = perpToward(abDirection, joinDirection);\r\n  vec2 cbNormal = perpToward(normalize(cb), joinDirection);\r\n  vec2 p1 = b + abNormal * halfLineWidth;\r\n  vec2 p2 = b + cbNormal * halfLineWidth;\r\n  vec2 b1 = p1 - b;\r\n  vec2 b2 = p2 - b;\r\n  // Make sure correct winding in case face culling is enabled.\r\n  bool p2IsRight = isRightOf(b2, b1);\r\n  d = iif(p2IsRight, p2, p1);\r\n  e = iif(p2IsRight, p1, p2);\r\n  bd = iif(p2IsRight, b2, b1);\r\n  be = iif(p2IsRight, b1, b2);\r\n  miter = normalize(bd + be);\r\n}\r\n\r\nvec2 addBevel(vec2 a, vec2 b, vec2 c, vec2 ab, float lineWidth, int vertexIndex) {\r\n  vec2 d, e, bd, be, miter;\r\n  joinCommon(a, b, c, ab, lineWidth, d, e, bd, be, miter);\r\n\r\n  // Find the closest point on the line (2D sdfPlane) containing de to b.\r\n  vec2 midPoint = (d + e) * 0.5;\r\n\r\n  tp[0] = b;\r\n  tp[1] = e;\r\n  tp[2] = d;\r\n  tp[3] = midPoint;\r\n  return iif(capFlags[JOIN_BEVEL], tp[vertexIndex - 7], emptyVertex);\r\n}\r\n\r\nvec2 addRoundJoin(vec2 a, vec2 b, vec2 c, vec2 ab, vec2 leftNormal, float lineWidth, int vertexIndex, inout float isWedge, inout vec2 center, inout vec2 radiusDir, inout float wedgeCrossLimit) {\r\n  vec2 d, e, bd, be, miter;\r\n  joinCommon(a, b, c, ab, lineWidth, d, e, bd, be, miter);\r\n  bool isActive = capFlags[JOIN_ROUND];\r\n  vec2 circleEdge = b + miter * (lineWidth * 0.5);\r\n\r\n  vec2 sD = modelToScreen(d);\r\n  vec2 circleEdgeS = modelToScreen(circleEdge);\r\n  isWedge = iif(isActive, 1.0, isWedge);\r\n  center = iif(isActive, modelToScreen(b), center);\r\n  radiusDir = iif(isActive, circleEdgeS - center, radiusDir);\r\n  wedgeCrossLimit = iif(isActive, cross(normalize(sD - center), normalize(radiusDir)), wedgeCrossLimit);\r\n\r\n  // Find the intersection of miter and the segment (2D sdfPlane) going through d.\r\n  vec2 normal = bd;            // Normal to the sdfPlane.\r\n  float nd = dot(normal, d);   // Distance to origin.\r\n  float t = (nd - dot(normal, b)) / dot(normal, miter);\r\n  vec2 miterPoint = b + miter * t;\r\n\r\n  tp[0] = b;\r\n  tp[1] = e;\r\n  tp[2] = d;\r\n  tp[3] = miterPoint;\r\n  return iif(isActive, tp[vertexIndex - 7], emptyVertex);\r\n}\r\n\r\nvec2 addMiter(vec2 a, vec2 b, vec2 c, vec2 ab, float lineWidth, float miterLimit, int miterFallback, int vertexIndex) {\r\n  vec2 d, e, bd, be, miter;\r\n  joinCommon(a, b, c, ab, lineWidth, d, e, bd, be, miter);\r\n\r\n  // Find the intersection of miter and the segment (2D sdfPlane) going through d.\r\n  vec2 normal = normalize(bd); // Normal to the sdfPlane.\r\n  float nd = dot(normal, d);   // Distance to origin.\r\n  float t = (nd - dot(normal, b)) / dot(normal, miter);\r\n  vec2 miterPoint = b + miter * t;\r\n\r\n  bool useFallback = t \u003e miterLimit;\r\n  capFlags[miterFallback] = capFlags[miterFallback] || (useFallback \u0026\u0026 capFlags[JOIN_MITER]);\r\n  capFlags[JOIN_MITER] = capFlags[JOIN_MITER] \u0026\u0026 !useFallback;\r\n\r\n  bool eIsRight = isRightOf(be, bd);\r\n  tp[0] = b;\r\n  tp[1] = e;\r\n  tp[2] = d;\r\n  tp[3] = miterPoint;\r\n  return iif(capFlags[JOIN_MITER], tp[vertexIndex - 7], emptyVertex);\r\n}\r\n\r\nvec2 addCap(int cap, vec2 point, vec2 direction, vec2 leftNormal, float lineWidth, int vertexIndex, inout float isSemicircle, inout vec2 center, inout vec2 radiusDir) {\r\n  vec2 buttOffset = vec2(0.0, lineTemplate[vertexIndex].y);\r\n\r\n  return addVerticies(capFlags[CAP_BUTT], buttOffset, point, direction, leftNormal, lineWidth, vertexIndex)\r\n    + addVerticies(capFlags[CAP_SQUARE], lineTemplate[vertexIndex], point, direction, leftNormal, lineWidth, vertexIndex)\r\n    + addVerticies(capFlags[CAP_ROUND], lineTemplate[vertexIndex], point, direction, leftNormal, lineWidth, vertexIndex)\r\n    + processRoundCap(point, direction, leftNormal, lineWidth, vertexIndex, isSemicircle, center, radiusDir);\r\n}\r\n\r\nvec2 addCap(int cap, float miterLimit, int miterFallback, vec2 point, vec2 a, vec2 b, vec2 c, vec2 direction, vec2 leftNormal, float lineWidth, int vertexIndex, inout float isSemicircle, inout float isWedge, inout vec2 center, inout vec2 radiusDir, inout float wedgeCrossLimit) {\r\n  return addMiter(a, b, c, direction, lineWidth, miterLimit, miterFallback, vertexIndex)\r\n    + addRoundJoin(a, b, c, direction, leftNormal, lineWidth, vertexIndex, isWedge, center, radiusDir, wedgeCrossLimit)\r\n    + addBevel(a, b, c, direction, lineWidth, vertexIndex)\r\n    + addCap(cap, point, direction, leftNormal, lineWidth, vertexIndex, isSemicircle, center, radiusDir)\r\n    ;\r\n}\r\n\r\nvec2 line2d(vec2 a, vec2 direction, vec2 leftNormal, float lineWidth, int vertexIndex) {\r\n  vec2 offset = lineTemplate[vertexIndex];\r\n  return a + direction * offset.x + leftNormal * (lineWidth * offset.y);\r\n}\r\n\r\nvec2 _line2d(vec2 a, vec2 direction, vec2 leftNormal, float lineWidth, int vertexIndex) {\r\n  vec2 vertex = line2d(a, direction, leftNormal, lineWidth, vertexIndex);\r\n  return iif(capFlags[CAP_LINE], vertex, emptyVertex);\r\n}\r\n\r\nvec2 line2d(vec2 a, vec2 b, float lineWidth, int cap, int vertexIndex, inout float isSemicircle, inout vec2 center, inout vec2 radiusDir) {\r\n  int section = iif(vertexIndex \u003c 4, 0, -1);\r\n  section = iif(vertexIndex \u003e 7, 2, section);\r\n  section = iif(section == -1, 1, section);\r\n\r\n  vec2 direction = b - a;\r\n  vec2 normalizedDirection = normalize(direction);\r\n  vec2 leftNormal = perp(normalizedDirection);\r\n  setCapFlag(cap, section == 0);\r\n  vec2 startVertex = addCap(cap, a, -normalizedDirection, leftNormal, lineWidth, vertexIndex, isSemicircle, center, radiusDir);\r\n  setCapFlag(CAP_LINE, section == 1);\r\n  vec2 lineVertex = _line2d(a, direction, leftNormal, lineWidth, vertexIndex);\r\n  setCapFlag(cap, section == 2);\r\n  vec2 endVertex = addCap(cap, b, normalizedDirection, leftNormal, lineWidth, vertexIndex, isSemicircle, center, radiusDir);\r\n  return startVertex + lineVertex + endVertex;\r\n}\r\n\r\nvec3 linepath2d(vec2 a, vec2 b, vec2 c, float lineWidth, int lineCap, int lineJoin, float miterLimit, int miterFallback, int instance, int instanceCount, int vertexIndex, inout float isSemicircle, inout float isWedge, inout vec2 center, inout vec2 radiusDir, inout float wedgeCrossLimit) {\r\n  int section = iif(vertexIndex \u003c 4, 0, -1);\r\n  section = iif(vertexIndex \u003e 7, 2, section);\r\n  section = iif(section == -1, 1, section);\r\n\r\n  int startCap = iif(instance == 0, lineCap, CAP_BUTT);\r\n  int endCap = iif(instance == instanceCount - 1, lineCap, lineJoin);\r\n  // int endCap = iif(instance == instanceCount - 1, lineCap, lineCap);\r\n\r\n  vec2 direction = b - a;\r\n  vec2 normalizedDirection = normalize(direction);\r\n  vec2 leftNormal = perp(normalizedDirection);\r\n  setCapFlag(startCap, section == 0);\r\n  vec2 startVertex = addCap(startCap, miterLimit, miterFallback, a, a, b, c, -normalizedDirection, leftNormal, lineWidth, vertexIndex, isSemicircle, isWedge, center, radiusDir, wedgeCrossLimit);\r\n  setCapFlag(CAP_LINE, section == 1);\r\n  vec2 lineVertex = _line2d(a, direction, leftNormal, lineWidth, vertexIndex);\r\n  setCapFlag(endCap, section == 2);\r\n  vec2 endVertex = addCap(endCap, miterLimit, miterFallback, b, a, b, c, normalizedDirection, leftNormal, lineWidth, vertexIndex, isSemicircle, isWedge, center, radiusDir, wedgeCrossLimit);\r\n  vec2 vertex = startVertex + lineVertex + endVertex;\r\n  return vec3(vertex, float(instanceCount - instance) * 0.00001);\r\n}"], ["lines2d3-vertex", "\r\n#include line-consts\r\n#include coordinate-conversion-vertex\r\n#include conditionals\r\n#include vec2\r\n#include line-utils\r\n#line 938\r\n\r\nconst int CAP_LINE = 6;\r\nint section;\r\n\r\nconst vec2 emptyVertex = vec2(0.0);\r\n\r\nbool capFlags[] = bool[7](false, false, false, false, false, false, false);\r\nvec2 tp[5];\r\n\r\nconst vec3 lineTemplate[] = vec3[8](\r\n  // Start\r\n  vec3(0.5,  0.5, 0.0),\r\n  vec3(0.5, -0.5, 0.0),\r\n  vec3(0.0,  0.5, 0.0),\r\n  vec3(0.0, -0.5, 0.0),\r\n\r\n  // Line\r\n  vec3(1.0,  0.5, 1.0),\r\n  vec3(1.0, -0.5, 1.0),\r\n\r\n  // End\r\n  vec3(0.5,  0.5, 2.0),\r\n  vec3(0.5, -0.5, 2.0)\r\n);\r\n\r\n// vec2 texCoords[] = vec2[10] (\r\n// );\r\n\r\nvoid setCapFlag(int cap, bool value) {\r\n  capFlags[CAP_BUTT] = false;\r\n  capFlags[CAP_SQUARE] = false;\r\n  capFlags[CAP_ROUND] = false;\r\n  capFlags[JOIN_ROUND] = false;\r\n  capFlags[JOIN_BEVEL] = false;\r\n  capFlags[JOIN_MITER] = false;\r\n  capFlags[CAP_LINE] = false;\r\n  capFlags[cap] = value;\r\n}\r\n\r\nvec2 addVerticies(bool flag, vec2 offset, vec2 point, vec2 direction, vec2 leftNormal, float lineWidth, int vertexIndex) {\r\n  vec2 vertex = point + direction * (lineWidth * offset.x) + leftNormal * (lineWidth * offset.y);\r\n  return iif(flag, vertex, emptyVertex);\r\n}\r\n\r\nvec2 processRoundCap(vec2 point, vec2 direction, vec2 leftNormal, float lineWidth, int vertexIndex, inout float isSemicircle, inout vec2 center, inout vec2 radiusDir) {\r\n  bool isActive = capFlags[CAP_ROUND];\r\n\r\n  vec2 sCircleEdge = modelToScreen(point + direction * (lineWidth * 0.5));\r\n  isSemicircle = iif(isActive, 1.0, isSemicircle);\r\n  center = iif(isActive, modelToScreen(point), center);\r\n  radiusDir = iif(isActive, sCircleEdge - center, radiusDir);\r\n  return emptyVertex;\r\n}\r\n\r\nvoid joinCommon(vec2 a, vec2 b, vec2 c, vec2 ab, float lineWidth, out vec2 d, out vec2 e, out vec2 bd, out vec2 be, out vec2 miter, out bool eIsRight) {\r\n  float halfLineWidth = lineWidth * 0.5;\r\n  vec2 cb = b - c;\r\n  vec2 abDirection = normalize(ab);\r\n  vec2 joinDirection = ab + cb;\r\n  vec2 abNormal = perpToward(abDirection, joinDirection);\r\n  vec2 cbNormal = perpToward(normalize(cb), joinDirection);\r\n  d = b + abNormal * halfLineWidth;\r\n  e = b + cbNormal * halfLineWidth;\r\n  bd = d - b;\r\n  be = e - b;\r\n  miter = normalize(bd + be);\r\n  eIsRight = isRightOf(be, bd);\r\n}\r\n\r\nvoid calcJoinPoints(vec2 b, vec2 d, vec2 e, vec2 middlePoint, bool eIsRight) {\r\n  tp[0] = iif(eIsRight, d, b);\r\n  tp[1] = iif(eIsRight, d, b);\r\n  tp[2] = iif(eIsRight, b, d);\r\n  tp[3] = iif(eIsRight, middlePoint, e);\r\n  tp[4] = iif(eIsRight, e, middlePoint);\r\n}\r\n\r\nvec2 addBevel(vec2 a, vec2 b, vec2 c, vec2 ab, float lineWidth, int vertexIndex) {\r\n  vec2 d, e, bd, be, miter;\r\n  bool eIsRight;\r\n  joinCommon(a, b, c, ab, lineWidth, d, e, bd, be, miter, eIsRight);\r\n\r\n  // Find the midpoint between d and e.\r\n  vec2 midPoint = (d + e) * 0.5;\r\n\r\n  calcJoinPoints(b, d, e, midPoint, eIsRight);\r\n  return iif(capFlags[JOIN_BEVEL], tp[vertexIndex - 5], emptyVertex);\r\n}\r\n\r\nvec2 addRoundJoin(vec2 a, vec2 b, vec2 c, vec2 ab, vec2 leftNormal, float lineWidth, int vertexIndex, inout float isCircle, inout vec2 center, inout vec2 radiusDir) {\r\n  vec2 d, e, bd, be, miter;\r\n  bool eIsRight;\r\n  joinCommon(a, b, c, ab, lineWidth, d, e, bd, be, miter, eIsRight);\r\n  bool isActive = capFlags[JOIN_ROUND];\r\n  vec2 circleEdge = b + miter * (lineWidth * 0.5);\r\n\r\n  vec2 sD = modelToScreen(d);\r\n  vec2 circleEdgeS = modelToScreen(circleEdge);\r\n  isCircle = iif(isActive, 1.0, isCircle);\r\n  center = iif(isActive, modelToScreen(b), center);\r\n  radiusDir = iif(isActive, circleEdgeS - center, radiusDir);\r\n\r\n  // Find the intersection of miter and the line (2D sdfPlane) going through d.\r\n  vec2 miterPoint = LineLineIntersection(b, miter, d, ab);\r\n\r\n  calcJoinPoints(b, d, e, miterPoint, eIsRight);\r\n  return iif(isActive, tp[vertexIndex - 5], emptyVertex);\r\n}\r\n\r\nvec2 addMiter(vec2 a, vec2 b, vec2 c, vec2 ab, float lineWidth, float miterLimit, int miterFallback, int vertexIndex) {\r\n  vec2 d, e, bd, be, miter;\r\n  bool eIsRight;\r\n  joinCommon(a, b, c, ab, lineWidth, d, e, bd, be, miter, eIsRight);\r\n\r\n  // Find the intersection of miter and the line (2D sdfPlane) going through d.\r\n  vec2 miterPoint = LineLineIntersection(b, miter, d, ab);\r\n\r\n  bool useFallback = length(miterPoint - b) \u003e miterLimit;\r\n  capFlags[miterFallback] = capFlags[miterFallback] || (useFallback \u0026\u0026 capFlags[JOIN_MITER]);\r\n  capFlags[JOIN_MITER] = capFlags[JOIN_MITER] \u0026\u0026 !useFallback;\r\n\r\n  calcJoinPoints(b, d, e, miterPoint, eIsRight);\r\n  return iif(capFlags[JOIN_MITER], tp[vertexIndex - 5], emptyVertex);\r\n}\r\n\r\nvec2 addCap(int cap, vec2 point, vec2 direction, vec2 leftNormal, float lineWidth, int vertexIndex, inout float isCircle, inout vec2 center, inout vec2 radiusDir) {\r\n  vec2 offset = lineTemplate[vertexIndex].xy;\r\n  vec2 buttOffset = vec2(0.0, offset.y);\r\n\r\n  return addVerticies(capFlags[CAP_BUTT], buttOffset, point, direction, leftNormal, lineWidth, vertexIndex)\r\n    + addVerticies(capFlags[CAP_SQUARE], offset, point, direction, leftNormal, lineWidth, vertexIndex)\r\n    + addVerticies(capFlags[CAP_ROUND], offset, point, direction, leftNormal, lineWidth, vertexIndex)\r\n    + processRoundCap(point, direction, leftNormal, lineWidth, vertexIndex, isCircle, center, radiusDir);\r\n}\r\n\r\nvec2 addCapOrJoin(int cap, float miterLimit, int miterFallback, vec2 point, vec2 a, vec2 b, vec2 c, vec2 direction, vec2 leftNormal, float lineWidth, int vertexIndex, inout float isCircle, inout vec2 center, inout vec2 radiusDir) {\r\n  return addMiter(a, b, c, direction, lineWidth, miterLimit, miterFallback, vertexIndex)\r\n    + addRoundJoin(a, b, c, direction, leftNormal, lineWidth, vertexIndex, isCircle, center, radiusDir)\r\n    + addBevel(a, b, c, direction, lineWidth, vertexIndex)\r\n    + addCap(cap, point, direction, leftNormal, lineWidth, vertexIndex, isCircle, center, radiusDir);\r\n}\r\n\r\nvec2 line2d(vec2 a, vec2 direction, vec2 leftNormal, float lineWidth, int vertexIndex) {\r\n  vec2 offset = lineTemplate[vertexIndex].xy;\r\n  return a + direction * offset.x + leftNormal * (lineWidth * offset.y);\r\n}\r\n\r\nvec2 _line2d(vec2 a, vec2 direction, vec2 leftNormal, float lineWidth, int vertexIndex) {\r\n  vec2 vertex = line2d(a, direction, leftNormal, lineWidth, vertexIndex);\r\n  return iif(capFlags[CAP_LINE], vertex, emptyVertex);\r\n}\r\n\r\nvec2 line2d(vec2 a, vec2 b, float lineWidth, int cap, int vertexIndex, inout float isCircle, inout vec2 center, inout vec2 radiusDir) {\r\n  int section = int(lineTemplate[vertexIndex].z);\r\n\r\n  vec2 direction = b - a;\r\n  vec2 normalizedDirection = normalize(direction);\r\n  vec2 leftNormal = perp(normalizedDirection);\r\n  setCapFlag(cap, section == 0);\r\n  vec2 startVertex = addCap(cap, a, -normalizedDirection, leftNormal, lineWidth, vertexIndex, isCircle, center, radiusDir);\r\n  setCapFlag(CAP_LINE, section == 1);\r\n  vec2 lineVertex = _line2d(a, direction, leftNormal, lineWidth, vertexIndex);\r\n  setCapFlag(cap, section == 2);\r\n  vec2 endVertex = addCap(cap, b, normalizedDirection, leftNormal, lineWidth, vertexIndex, isCircle, center, radiusDir);\r\n  return startVertex + lineVertex + endVertex;\r\n}\r\n\r\nvec3 linepath2d(vec2 a, vec2 b, vec2 c, float lineWidth, int lineCap, int lineJoin, float miterLimit, int miterFallback, int instance, int instanceCount, int vertexIndex, inout float isCircle, inout vec2 center, inout vec2 radiusDir) {\r\n  int section = int(lineTemplate[vertexIndex].z);\r\n  int startCap = iif(instance == 0, lineCap, CAP_BUTT);\r\n  int endCap = iif(instance == instanceCount - 1, lineCap, lineJoin);\r\n\r\n  vec2 direction = b - a;\r\n  vec2 normalizedDirection = normalize(direction);\r\n  vec2 leftNormal = perp(normalizedDirection);\r\n  setCapFlag(startCap, section == 0);\r\n  vec2 startVertex = addCap(startCap, a, -normalizedDirection, leftNormal, lineWidth, vertexIndex, isCircle, center, radiusDir);\r\n  setCapFlag(CAP_LINE, section == 1);\r\n  vec2 lineVertex = _line2d(a, direction, leftNormal, lineWidth, vertexIndex);\r\n  setCapFlag(endCap, section == 2);\r\n  vec2 endVertex = addCapOrJoin(endCap, miterLimit, miterFallback, b, a, b, c, normalizedDirection, leftNormal, lineWidth, vertexIndex, isCircle, center, radiusDir);\r\n  vec2 vertex = startVertex + lineVertex + endVertex;\r\n  // Fudge the z component to allow removal of rear faces in transparent lines.\r\n  // NEEDS SOME WORK: Does not play well with other objects.\r\n  float z = iif(section == 1, float(instanceCount - instance) * 0.00001, 0.0);\r\n  z = 0.0;\r\n  return vec3(vertex, z);\r\n}"], ["lines2d4-vertex", "\r\n// lines2d4-vertex\r\n#include line-consts\r\n#include sdf-consts\r\n#include coordinate-conversion-vertex\r\n#include line-utils\r\n#line 1396\r\n\r\nvec4 offsets[] = vec4[4] (\r\n  vec4(0.0,  1.1, -1.0, 0.0), // x,y: offset. z: direction to add half line width for caps.\r\n  vec4(0.0, -1.1, -1.0, 0.0), // z: add offset for miter.\r\n  vec4(1.0,  1.1,  1.0, 1.0),\r\n  vec4(1.0, -1.1,  1.0, 1.0)\r\n);\r\n\r\nSdfLineParams createLinePathParams(int instance, int instanceCount, float miterLimit, int miterFallback, int lineCap, int lineJoin, vec2 a, vec2 b, vec2 c, float hlw, out float lineLength, out vec2 rotation) {\r\n  vec2 ab = b - a;\r\n  vec2 cb = b - c;\r\n  lineLength = length(ab);\r\n  vec2 abDir = normalize(ab);\r\n  vec2 abNormal = perp(abDir);\r\n  vec2 cbNormal = perp(normalize(cb));\r\n  vec2 startBottomLeft = a - abDir * hlw + abNormal * -hlw;\r\n  vec2 endTopRight = b + abDir * hlw + abNormal * hlw;\r\n  vec2 bottomLeft = a + abNormal * -hlw;\r\n  vec2 topRight = b + abNormal * hlw;\r\n\r\n  vec2 joinDirection = ab + cb;\r\n  abNormal = faceToward(abNormal, joinDirection);\r\n  cbNormal = faceToward(cbNormal, joinDirection);\r\n  vec2 d = b + cbNormal * hlw;\r\n  vec2 e = b + abNormal * hlw;\r\n  vec2 bd = d - b;\r\n  vec2 be = e - b;\r\n  vec2 miter = normalize(bd + be);\r\n\r\n  // Find the intersection of miter and the line (2D sdfPlane) going through d.\r\n  vec2 miterPoint = LineLineIntersection(b, miter, d, cb);\r\n\r\n  float lineAngle = atan(ab.y, ab.x);\r\n  rotation = vec2(cos(lineAngle), sin(lineAngle));\r\n  lineAngle = -lineAngle; // TODO: Figure out what\u0027s going on here with negative.\r\n\r\n  vec2 bS = modelToScreen(b);\r\n  vec2 miterPointS = modelToScreen(miterPoint);\r\n\r\n  float isLastInstance = float(instance == instanceCount - 1);\r\n  int startCap = int(mix(float(CAP_BUTT), float(lineCap), float(instance == 0)));\r\n  int endCap = int(mix(float(lineJoin), float(lineCap), isLastInstance));\r\n  bool useFallback = isLastInstance == 0.0 \u0026\u0026 endCap == JOIN_MITER \u0026\u0026 length(miterPointS - bS) \u003e miterLimit;\r\n  endCap = int(mix(float(endCap), float(miterFallback), useFallback));\r\n\r\n  float dIsRight = float(isRightOf(bd, be));\r\n\r\n  SdfLineParams result;\r\n  result.startCap = startCap;\r\n  result.endCap = endCap;\r\n  result.position = modelToScreen(a);\r\n  result.rotation = vec2(cos(lineAngle), sin(lineAngle));\r\n  result.startBottomLeft = modelToScreen(startBottomLeft);\r\n  result.endTopRight = modelToScreen(endTopRight);\r\n  result.bottomLeft = modelToScreen(bottomLeft);\r\n  result.topRight = modelToScreen(topRight);\r\n  result.join1 = bS;\r\n  result.join2 = modelToScreen(mix(e, d, dIsRight));\r\n  result.join3 = modelToScreen(mix(d, e, dIsRight));\r\n  result.miterPoint = miterPointS;\r\n  result.hasPrior = float(instance \u003e 0);\r\n  result.hasNext = float(instance \u003c instanceCount - 1);\r\n  return result;\r\n}\r\n\r\nvec2 linepath2d(vec2 priorA, vec2 a, vec2 b, vec2 c, float lineWidth, int lineCap, int lineJoin, float miterLimit, int miterFallback, int instance, int instanceCount, int vertexIndex, float aliasWidth, float worldScale, out SdfLineParams lineParams, out SdfLineParams priorLineParams, out SdfLineParams nextLineParams) {\r\n  vec2 pts[] = vec2[] (priorA, a, b, c );\r\n  float miterLimitS = miterLimit * worldScale;\r\n  float hlw = lineWidth * 0.5;\r\n\r\n  vec2 rotation;\r\n  float lineLength;\r\n  priorLineParams = createLinePathParams(instance - 1, instanceCount, miterLimitS, miterFallback, lineCap, lineJoin, priorA, a, b, hlw, lineLength, rotation);\r\n  nextLineParams = createLinePathParams(instance + 1, instanceCount, miterLimitS, miterFallback, lineCap, lineJoin, b, c, vec2(0.0, 0.0), hlw, lineLength, rotation);\r\n  lineParams = createLinePathParams(instance, instanceCount, miterLimitS, miterFallback, lineCap, lineJoin, a, b, c, hlw, lineLength, rotation);\r\n  lineParams.aliasWidth = aliasWidth;\r\n\r\n  vec4 offset = offsets[vertexIndex];\r\n  float miterOffset = mix(0.0, offset.w, lineParams.hasNext == 1.0);\r\n  float startHlw = mix(0.0, -hlw, offset.x \u003c 1.0);\r\n  float endHlw = mix(0.0, hlw, offset.x \u003e 0.0 \u0026\u0026 lineParams.hasNext == 0.0);\r\n  vec2 v = offset.xy * vec2(lineLength, hlw) + vec2(startHlw + endHlw + ((miterLimit * 1.7) * miterOffset), 0.0);\r\n  v = rotate(v, rotation) + a;\r\n  return v;\r\n}"], ["vector2d", "\r\n#include vec2\r\n\r\nconst vec2 vecTemplate[] = vec2[9](\r\n  vec2(0.0, -0.5),\r\n  vec2(0.85, -0.5),\r\n  vec2(0.0,  0.5),\r\n\r\n  vec2(0.85, -0.5),\r\n  vec2(0.85,  0.5),\r\n  vec2(0.0,   0.5),\r\n\r\n  vec2(0.85, -1.0),\r\n  vec2(1.0,  0.0),\r\n  vec2(0.85,  1.0)\r\n);\r\n\r\nvec2 vector2d(vec2 vec, float lineWidth, int vertexID, out float isTip) {\r\n  isTip = step(7.0, float(vertexID));\r\n  vec2 leftNormal = normalize(perp(vec));\r\n  vec2 offset = vecTemplate[vertexID];\r\n  return vec2(0.0) + vec * offset.x + leftNormal * (lineWidth * offset.y);\r\n }"], ["noise-fractal-params", "\r\nuniform noiseFractalParams {\r\n  int octaves;\r\n  vec4 frequency;\r\n  float amplitude;\r\n  float lacunarity;\r\n  float gain;\r\n  float noiseTime;\r\n};"], ["noise-outvars", "\r\nflat out vec4 v_noiseStart;\r\nflat out vec3 v_noiseDim;\r\nflat out vec2 v_noiseCenterLeft;\r\nflat out vec2 v_noiseCenterRight;\r\nflat out vec2 v_noiseCenterTop;\r\nflat out vec2 v_noiseCenterBottom;\r\nflat out float v_noiseRange;"], ["noise-invars", "\r\nuniform sampler2D permTexture;\r\nflat in vec4 v_noiseStart;\r\nflat in vec3 v_noiseDim;\r\nflat in vec2 v_noiseCenterLeft;\r\nflat in vec2 v_noiseCenterRight;\r\nflat in vec2 v_noiseCenterTop;\r\nflat in vec2 v_noiseCenterBottom;\r\nflat in float v_noiseRange;"], ["perlin-noise", "\r\n#include conditionals\r\n#line 1187\r\n\r\nvec2 add(vec2 v, float x, float y) { return vec2(v.x + x, v.y + y); }\r\nvec3 add(vec3 v, float x, float y, float z) { return vec3(v.x + x, v.y + y, v.z + z); }\r\nvec4 add(vec4 v, float x, float y, float z, float w) { return vec4(v.x + x, v.y + y, v.z + z, v.w + w); }\r\n\r\nfloat fade(float t) { return t * t * t * (t * (t * 6.0 - 15.0) + 10.0); }\r\n\r\nint perm(int idx) { return int(texelFetch(permTexture, ivec2(idx, 0), 0).r * 255.0) \u0026 0xFF; }\r\nint perm(int x, int y) { return perm(perm(x) + y); }\r\nint perm(int x, int y, int z) { return perm(perm(perm(x) + y) + z); }\r\n\r\nfloat grad(int hash, float p) {\r\n  return float[2] (-p, p)[hash \u0026 1];\r\n}\r\n\r\nfloat grad(int hash, vec2 p) {\r\n  // TODO: Test if this is more efficient than using a switch.\r\n  return float[4] (\r\n     p.x + p.y,\r\n    -p.x + p.y,\r\n     p.x - p.y,\r\n    -p.x - p.y\r\n  )[hash \u0026 3];\r\n}\r\n\r\nfloat grad(int hash, vec3 p) {\r\n  // TODO: This is probably less efficient than using a switch. Test.\r\n  return float[16] (\r\n     p.x + p.y,\r\n    -p.x + p.y,\r\n     p.x - p.y,\r\n    -p.x - p.y,\r\n\r\n     p.x + p.z,\r\n    -p.x + p.z,\r\n     p.x - p.z,\r\n    -p.x - p.z,\r\n     p.y + p.z,\r\n    -p.y + p.z,\r\n     p.y - p.z,\r\n    -p.y - p.z, // 12th\r\n     p.x + p.y,\r\n    -p.x + p.y,\r\n    -p.y + p.z,\r\n    -p.y - p.z\r\n  )[hash \u0026 0xF];\r\n}\r\n\r\nfloat grad(int hash, vec4 p) {\r\n  // TODO: This is probably less efficient than using a switch. Test.\r\n  return float[32] (\r\n     p.x +  p.y +  p.w,\r\n    -p.x +  p.y +  p.w,\r\n     p.x + -p.y +  p.w,\r\n    -p.x + -p.y +  p.w,\r\n     \r\n     p.x +  p.z +  p.w,\r\n    -p.x +  p.z +  p.w,\r\n     p.x + -p.z +  p.w,\r\n    -p.x + -p.z +  p.w,\r\n\r\n     p.y +  p.z +  p.w,\r\n    -p.y +  p.z +  p.w,\r\n     p.y + -p.z +  p.w,\r\n    -p.y + -p.z +  p.w,\r\n\r\n     p.x +  p.y + -p.w,\r\n    -p.x +  p.y + -p.w,\r\n     p.x + -p.y + -p.w,\r\n    -p.x + -p.y + -p.w,\r\n\r\n     p.x +  p.z + -p.w,\r\n    -p.x +  p.z + -p.w,\r\n     p.x + -p.z + -p.w,\r\n    -p.x + -p.z + -p.w,\r\n\r\n     p.y +  p.z + -p.w,\r\n    -p.y +  p.z + -p.w,\r\n     p.y + -p.z + -p.w,\r\n    -p.y + -p.z + -p.w,\r\n\r\n     p.x +  p.y +  p.z,\r\n    -p.x +  p.y +  p.z,\r\n     p.x + -p.y + -p.z,\r\n    -p.x + -p.y + -p.z,\r\n\r\n     p.x +  p.y + -p.z,\r\n    -p.x +  p.y + -p.z,\r\n     p.x + -p.y +  p.z,\r\n    -p.x + -p.y +  p.z\r\n   )[hash \u0026 0x1F];\r\n}\r\n\r\nfloat _noise(float p) {\r\n  float p0 = fract(p);\r\n  float p1 = p0 - 1.0;\r\n  \r\n  int idx = int(floor(p));\r\n  int v0 = perm(idx);\r\n  int v1 = perm(idx + 1);\r\n\r\n  float fx = fade(p0);\r\n  return mix(grad(v0, p0), grad(v1, p1), fx);\r\n}\r\n\r\nfloat _noise(vec2 p) {\r\n  vec2 p0 = fract(p);            // By subtracting, we are actually\r\n  vec2 p1 = add(p0, -1.0,  0.0); // Calculating the vector from each\r\n  vec2 p2 = add(p0,  0.0, -1.0); // corner to p.\r\n  vec2 p3 = add(p0, -1.0, -1.0);\r\n\r\n  ivec2 id = ivec2(floor(p));\r\n  int v0 = perm(id.x    , id.y    );\r\n  int v1 = perm(id.x + 1, id.y    );\r\n  int v2 = perm(id.x    , id.y + 1);\r\n  int v3 = perm(id.x + 1, id.y + 1);\r\n\r\n  float fx = fade(p0.x);\r\n  float fy = fade(p0.y);\r\n  float a = mix(grad(v0, p0), grad(v1, p1), fx);\r\n  float b = mix(grad(v2, p2), grad(v3, p3), fx);\r\n  return mix(a, b, fy);\r\n}\r\n\r\nfloat _noise(vec3 p) {\r\n  vec3 p0 = fract(p);\r\n  vec3 p1 = add(p0, -1.0,  0.0,  0.0);\r\n  vec3 p2 = add(p0,  0.0, -1.0,  0.0);\r\n  vec3 p3 = add(p0, -1.0, -1.0,  0.0);\r\n  vec3 p4 = add(p0,  0.0,  0.0, -1.0);\r\n  vec3 p5 = add(p0, -1.0,  0.0, -1.0);\r\n  vec3 p6 = add(p0,  0.0, -1.0, -1.0);\r\n  vec3 p7 = add(p0, -1.0, -1.0, -1.0);\r\n\r\n  ivec3 id = ivec3(floor(p));\r\n  int v0 = perm(id.x    , id.y    , id.z    );\r\n  int v1 = perm(id.x + 1, id.y    , id.z    );\r\n  int v2 = perm(id.x    , id.y + 1, id.z    );\r\n  int v3 = perm(id.x + 1, id.y + 1, id.z    );\r\n  int v4 = perm(id.x    , id.y    , id.z + 1);\r\n  int v5 = perm(id.x + 1, id.y    , id.z + 1);\r\n  int v6 = perm(id.x    , id.y + 1, id.z + 1);\r\n  int v7 = perm(id.x + 1, id.y + 1, id.z + 1);\r\n\r\n  float fx = fade(p0.x);\r\n  float fy = fade(p0.y);\r\n  float fz = fade(p0.z);\r\n  float a1 = mix(grad(v0, p0), grad(v1, p1), fx);\r\n  float b1 = mix(grad(v2, p2), grad(v3, p3), fx);\r\n  float a2 = mix(grad(v4, p4), grad(v5, p5), fx);\r\n  float b2 = mix(grad(v6, p6), grad(v7, p7), fx);\r\n  float c1 = mix(a1, b1, fy);\r\n  float c2 = mix(a2, b2, fy);\r\n  return mix(c1, c2, fz);\r\n}\r\n\r\nfloat noise(float p) {\r\n  float freq = frequency.x;\r\n  float amp = amplitude;\r\n  float result = 0.0;\r\n  int oct = max(octaves, 1);\r\n\r\n  for (int i = 0; i \u003c oct; i++) {\r\n    result += _noise(p * freq) * amp;\r\n    freq *= lacunarity;\r\n    amp *= gain;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfloat noise(vec2 p) {\r\n  vec2 freq = frequency.xy;\r\n  float amp = amplitude;\r\n  float result = 0.0;\r\n  int oct = max(octaves, 1);\r\n\r\n  for (int i = 0; i \u003c oct; i++) {\r\n    result += _noise(p * freq) * amp;\r\n    freq *= lacunarity;\r\n    amp *= gain;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfloat noise(vec3 p) {\r\n  vec3 freq = frequency.xyz;\r\n  float amp = amplitude;\r\n  float result = 0.0;\r\n  int oct = max(octaves, 1);\r\n\r\n  for (int i = 0; i \u003c oct; i++) {\r\n    result += _noise(p * freq) * amp;\r\n    freq *= lacunarity;\r\n    amp *= gain;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfloat turbulence1(vec2 pos, float loFreq, float hiFreq) {\r\n  float t = 0.0;\r\n  vec2 p = vec2(pos.x + 123.456, pos.y);\r\n\r\n  for (float freq = loFreq; freq \u003c hiFreq; freq *= 2.0) {\r\n    t += abs(_noise(p)) / freq;\r\n    p *= 2.0;\r\n  }\r\n\r\n  return t;// - 0.3; // Avg 0.0.\r\n}\r\n\r\nfloat turbulence(vec2 pos, float pixelSize) {\r\n  float t = 0.0;\r\n  vec2 p = pos.xy;\r\n\r\n  for (float scale = 1.0; scale \u003e pixelSize; scale *= 0.5) {\r\n    p /= scale;\r\n    t += abs(_noise(p)) * scale;\r\n  }\r\n\r\n  return t;// - 0.3;\r\n}\r\n\r\nfloat turbulence(vec3 pos, float pixelSize) {\r\n  float t = 0.0;\r\n  vec3 p = pos.xyz;\r\n\r\n  for (float scale = 1.0; scale \u003e pixelSize; scale *= 0.5) {\r\n    p /= scale;\r\n    t += abs(_noise(p)) * scale;\r\n  }\r\n\r\n  return t;// - 0.3;\r\n}\r\n  "]]));

const DefaultValues_shaderIncludeVertexTexture2d0 = "\r\nin vec2 a_texCoords0;\r\nout vec2 v_texCoords0;\r\n";

const DefaultValues_shaderIncludeUseVertexTexture2d0 = "\r\n  gl_Position *= vec4(a_texCoords0 / a_texCoords0, 1.0, 1.0);\r\n";

const DefaultValues_shaderIncludeFragmentTexture2d0 = "\r\nuniform sampler2D u_texture0;\r\nin vec2 v_texCoords0;\r\n";

const DefaultValues_shaderIncludeUseFragmentTexture2d0 = "\r\n  glFragColor *= texture(u_texture0, v_texCoords0);\r\n";

(function () {
    const enumerator = getEnumerator(ofSeq_2(rangeNumber(0, 1, 15)));
    try {
        while (enumerator["System.Collections.IEnumerator.MoveNext"]()) {
            const i = enumerator["System.Collections.Generic.IEnumerator`1.get_Current"]() | 0;
            WebglShaderUtils_addShaderInclude(toText(interpolate("vertex-texture2d%P()", [i])), replace_1(DefaultValues_shaderIncludeVertexTexture2d0, "0", toText(interpolate("%P()", [i]))));
            WebglShaderUtils_addShaderInclude(toText(interpolate("use-vertex-texture2d%P()", [i])), replace_1(DefaultValues_shaderIncludeUseVertexTexture2d0, "0", toText(interpolate("%P()", [i]))));
            WebglShaderUtils_addShaderInclude(toText(interpolate("fragment-texture2d%P()", [i])), replace_1(DefaultValues_shaderIncludeFragmentTexture2d0, "0", toText(interpolate("%P()", [i]))));
            WebglShaderUtils_addShaderInclude(toText(interpolate("use-fragment-texture2d%P()", [i])), replace_1(DefaultValues_shaderIncludeUseFragmentTexture2d0, "0", toText(interpolate("%P()", [i]))));
        }
    }
    finally {
        enumerator.Dispose();
    }
})();

iterate((tupledArg) => {
    DefaultValues_addVertex(tupledArg[0], tupledArg[1]);
}, ofArray([["emptyVertex", "#version 300 es\r\n// emptyVertex\r\nvoid main() {\r\n  gl_Position = vec4(0.0);\r\n}"], ["globalVertex2d", "#version 300 es\r\n// globalVertex2d\r\n#include precision\r\n#include global-ubo\r\n\r\nvoid main() {\r\n  gl_Position = vec4(0.0);\r\n}"], ["sharedCameraVertex2d", "#version 300 es\r\n// sharedCameraVertex2d\r\n#include precision\r\n#include camera-ubo\r\n\r\nvoid main() {\r\n  gl_Position = projMat * viewMat * vec4(0.0);\r\n}"], ["fullSizeVertex2d", "#version 300 es\r\n// fullSizeVertex2d\r\n#include precision\r\n#include global-ubo\r\n#include path-outvars\r\n\r\nvec2 points[] = vec2[4] (\r\n  vec2(-1.0, -1.0),\r\n  vec2(1.0, -1.0),\r\n  vec2(-1.0, 1.0),\r\n  vec2(1.0, 1.0)\r\n);\r\n\r\nvoid main() {\r\n  int vertexID = gl_VertexID % 4;\r\n\r\n  gl_Position = vec4(points[vertexID], 0.0, 1.0);\r\n  // vec4 c[] = vec4[4](\r\n  //   vec4(1.0, 0.0, 0.0, 1.0),\r\n  //   mix(vec4(1.0, 0.0, 0.0, 1.0), vec4(0.0, 0.0, 1.0, 1.0), 0.5),\r\n  //   mix(vec4(1.0, 0.0, 0.0, 1.0), vec4(0.0, 0.0, 1.0, 1.0), 0.5),\r\n  //   vec4(0.0, 0.0, 1.0, 1.0)\r\n  // );\r\n  // v_fillColor = c[vertexID];\r\n}"], ["quadStripVertex2d", "#version 300 es\r\n// quadStripVertex2d\r\n#include precision\r\n#include quad-params\r\n#include quad-outvars\r\n#include quad-points-strip\r\n#include coordinate-conversion-vertex\r\n#include vec2\r\n\r\nvoid main() {\r\n  vec2[] points = quadPointsStrip;\r\n#include calc-quad-vertexid\r\n#include calc-scaled-quad-points\r\n#include calc-quad-dim\r\n#include calc-quad-center\r\n#include calc-quad-rotation\r\n#include calc-quad-vertex\r\n#include set-quad-position\r\n#include set-quad-params\r\n}"], ["quadStripRightVertex2d", "#version 300 es\r\n// quadStripRightVertex2d\r\n#include precision\r\n#include quad-params\r\n#include quad-outvars\r\n#include quad-points-strip-right\r\n#include coordinate-conversion-vertex\r\n#include vec2\r\n\r\nvoid main() {\r\n  vec2[] points = quadPointsStripRight;\r\n#include calc-quad-vertexid\r\n#include calc-scaled-quad-points\r\n#include calc-quad-dim\r\n#include calc-quad-center\r\n#include calc-quad-rotation\r\n#include calc-quad-vertex\r\n#include set-quad-position\r\n#include set-quad-params\r\n}"], ["sdf", "#version 300 es\r\n// sdf\r\n#include precision\r\n#include global-ubo\r\n#include math-consts\r\n#include line-consts\r\n#include path-outvars\r\n#include sdf-consts\r\n#include sdf-outvars\r\n#include coordinate-conversion-vertex\r\n#include vec2\r\n#include lines2d4-vertex\r\n#line 1865\r\n\r\nuniform int instanceCount;\r\n\r\nin vec2 p1;\r\nin vec2 p2;\r\nin vec2 p3;\r\nin vec2 p4;\r\n\r\nvoid main() {\r\n  int lineCap;\r\n  lineCap = CAP_BUTT;\r\n  lineCap = CAP_SQUARE;\r\n  lineCap = CAP_ROUND;\r\n\r\n  int lineJoin;\r\n  lineJoin = JOIN_ROUND;\r\n  // lineJoin = JOIN_BEVEL;\r\n  lineJoin = JOIN_MITER;\r\n\r\n  int vertexIndex = gl_VertexID;\r\n  int triangleID = int(gl_VertexID \u003e= 3);\r\n  int instance = gl_InstanceID;\r\n\r\n  float worldScale = 66.66;\r\n  float lineWidthScale = 1.0 / worldScale;\r\n  float lineWidth = 80.0 * lineWidthScale;\r\n  float hlw = lineWidth * 0.5;\r\n  float strokeWidth = lineWidth * worldScale;\r\n  strokeWidth *= v_scale;\r\n\r\n  float miterLimit = 2.0;\r\n  float miterLimitS = miterLimit * worldScale;\r\n  int miterFallback = JOIN_BEVEL;\r\n\r\n  vec2 priorA = p1;\r\n  vec2 a = p2;\r\n  vec2 b = p3;\r\n  vec2 c = p4;\r\n  \r\n  float angle = fract(time * 0.055) * TWO_PI;\r\n  if (instance == 0) {\r\n    b = rotate(b, vec2(cos(angle), sin(angle)));\r\n  } else {\r\n    a = rotate(a, vec2(cos(angle), sin(angle)));\r\n  }\r\n\r\n  vec2 vertex = linepath2d(priorA, a, b, c, lineWidth, lineCap, lineJoin, miterLimit, miterFallback, instance, instanceCount, vertexIndex, worldScale, v_sdfLineParams, v_sdfPriorLineParams, v_sdfNextLineParams);\r\n\r\n  gl_Position = modelToClip(vertex);\r\n  v_aliasWidth = 2.0;\r\n\r\n  v_strokeWidth = strokeWidth;\r\n  v_strokeColor = vec4(0.0, 1.0, 0.0, 0.2);\r\n  v_strokeColor = vec4(1.0, 0.5, 1.0, 0.4);\r\n  v_fillColor = vec4(1.0, 0.0, 0.0, 1.0);\r\n  if (instanceCount \u003c 2) v_strokeColor = vec4(0.0, 1.0, 0.0, 0.2);\r\n  // if (angle \u003e 0.0) v_fillColor = vec4(0.0, 0.0, 0.0, 1.0);\r\n  // if (triangleID == 1) v_fillColor = vec4(0.0, 0.0, 1.0, 1.0);\r\n}"]]));

iterate((tupledArg) => {
    DefaultValues_addFragment(tupledArg[0], tupledArg[1]);
}, ofArray([["sdf", "#version 300 es\r\n// sdf\r\n#include precision\r\n#include global-ubo\r\n#include transparent-color\r\n#include path-invars\r\n#include out-color-fragment\r\n#include sdf-consts\r\n#include sdf-invars\r\n#include sdf-linepath-fragment\r\n#line 1910\r\n\r\nvoid main() {\r\n  vec4 color = sdfDrawLinePath(\r\n    v_sdfLineParams,\r\n    v_sdfPriorLineParams,\r\n    v_sdfNextLineParams,\r\n    v_strokeColor,\r\n    v_aliasWidth,\r\n    resolution * 0.5);\r\n\r\n  vec2 p = gl_FragCoord.xy;\r\n  // float dist = length(p - v_sdfLineParams.join1);\r\n  // if (dist \u003c= 5.0) color = vec4(0.5, 0.0, 0.0, 1.0);\r\n  // dist = length(p - v_sdfLineParams.join2);\r\n  // if (dist \u003c= 5.0) color = vec4(0.0, 1.0, 0.0, 1.0);\r\n  // dist = length(p - v_sdfLineParams.miterPoint);\r\n  // if (dist \u003c= 5.0) color = vec4(0.0, 0.0, 1.0, 1.0);\r\n  // dist = length(p - v_sdfLineParams.join3);\r\n  // if (dist \u003c= 5.0) color = vec4(1.0, 1.0, 0.0, 1.0);\r\n\r\n  // float dist = length(p - v_sdfLineParams.startBottomLeft);\r\n  // if (dist \u003c= 5.0) color = vec4(0.5, 0.0, 0.0, 1.0);\r\n  // dist = length(p - v_sdfLineParams.bottomLeft);\r\n  // if (dist \u003c= 5.0) color = vec4(0.0, 1.0, 0.0, 1.0);\r\n  // dist = length(p - v_sdfLineParams.topRight);\r\n  // if (dist \u003c= 5.0) color = vec4(0.0, 0.0, 1.0, 1.0);\r\n  // dist = length(p - v_sdfLineParams.endTopRight);\r\n  // if (dist \u003c= 5.0) color = vec4(1.0, 1.0, 0.0, 1.0);\r\n\r\n  glFragColor = color;\r\n}"], ["emptyFragment", "#version 300 es\r\n// emptyFragment\r\n#include precision\r\n#include out-color-fragment\r\n\r\nvoid main() {\r\n  glFragColor = vec4(0.0);\r\n}"], ["simpleFragment2d", "#version 300 es\r\n// simpleFragment2d\r\n#include precision\r\n#include path-invars\r\n#include out-color-fragment\r\n\r\nvoid main() {\r\n  glFragColor = v_fillColor;\r\n}"], ["simpleQuadFragment2d", "#version 300 es\r\n// simpleQuadFragment2d\r\n#include precision\r\n#include quad-common\r\n#include quad-invars\r\n#include out-color-fragment\r\n\r\nvoid main() {\r\n  glFragColor = v_params.fillColor;\r\n}"], ["simpleQuadSdfFragment2d", "#version 300 es\r\n// simpleQuadSdfFragment2d\r\n#include precision\r\n#include global-ubo\r\n#include quad-common\r\n#include quad-invars\r\n#include out-color-fragment\r\n#include sdf-utils\r\n\r\nfloat sdfRect(vec2 p, QuadParams params) {\r\n  vec2 size = params.halfSize;\r\n  return max(abs(p.x) - size.x, abs(p.y) - size.y);\r\n}\r\n\r\nvoid main() {\r\n  vec2 halfResolution = resolution * 0.5;\r\n  vec2 p = sdfToLocalOrient(gl_FragCoord.xy, v_params);\r\n\r\n  vec4 color;\r\n  color = sdfDraw(sdfRect(p, v_params), v_params);\r\n\r\n  glFragColor = color;\r\n}"], ["circleFragment2d", "#version 300 es\r\n// circleFragment2d\r\n#include precision\r\n#include path-invars\r\n#include circle-invars\r\n#include out-color-fragment\r\n#include circles-fragment\r\n\r\nvoid main() {\r\n#include init-color\r\n#include circle-color-fragment\r\n#include set-out-color\r\n}"], ["circleDiscardFragment2d", "#version 300 es\r\n// circleDiscardFragment2d\r\n#include precision\r\n#include path-invars\r\n#include circle-invars\r\n#include out-color-fragment\r\n#include circles-fragment\r\n\r\nvoid main() {\r\n#include init-color\r\n#include circle-color-discard-fragment\r\n#include set-out-color\r\n}"], ["semicircleFragment2d", "#version 300 es\r\n// semicircleFragment2d\r\n#include precision\r\n#include path-invars\r\n#include circle-invars\r\n#include out-color-fragment\r\n#include circles-fragment\r\n\r\nvoid main() {\r\n#include init-color\r\n#include semicircle-color-fragment\r\n#include set-out-color\r\n}"], ["semicircleDiscardFragment2d", "#version 300 es\r\n// semicircleDiscardFragment2d\r\n#include precision\r\n#include path-invars\r\n#include circle-invars\r\n#include out-color-fragment\r\n#include circles-fragment\r\n\r\nvoid main() {\r\n#include init-color\r\n#include semicircle-color-discard-fragment\r\n#include set-out-color\r\n}"], ["semicircleWedgeFragment2d", "#version 300 es\r\n// semicircleWedgeFragment2d\r\n#include precision\r\n#include path-invars\r\n#include circle-invars\r\n#include out-color-fragment\r\n#include circles-fragment\r\n\r\nvoid main() {\r\n#include init-color\r\n#include semicircle-color-fragment\r\n#include wedge-color-fragment\r\n#include set-out-color\r\n}"], ["semicircleWedgeDiscardFragment2d", "#version 300 es\r\n// semicircleWedgeDiscardFragment2d\r\n#include precision\r\n#include path-invars\r\n#include circle-invars\r\n#include out-color-fragment\r\n#include circles-fragment\r\n\r\nvoid main() {\r\n#include init-color\r\n#include semicircle-color-discard-fragment\r\n#include wedge-color-discard-fragment\r\n#include set-out-color\r\n}"], ["linepath2d-fragment", "#version 300 es\r\n// linepath2d-fragment\r\n#include precision\r\n#include global-ubo\r\n#include transparent-color\r\n#include path-invars\r\n#include out-color-fragment\r\n#include sdf-consts\r\n#include sdf-line-invars\r\n#include sdf-linepath-fragment\r\n#line 2085\r\n\r\nvoid main() {\r\n  vec4 color = sdfDrawLinePath(\r\n    v_sdfLineParams,\r\n    v_sdfPriorLineParams,\r\n    v_sdfNextLineParams,\r\n    v_strokeColor,\r\n    v_aliasWidth);\r\n\r\n  glFragColor = color;\r\n}"], ["vectorFragment2d", "#version 300 es\r\n// simpleQuadSdfFragment2d\r\n#include precision\r\n#include math-consts\r\n#include global-ubo\r\n#include quad-common\r\n#include quad-invars\r\n#include out-color-fragment\r\n#include vec2\r\n#include line-utils\r\n#include sdf-utils\r\n#line 2447\r\n\r\nvoid calcSlopeIntercept(vec2 p1, vec2 p2, out float slope, out float xIntercept, out float yIntercept) {\r\n  float run = (p2.x - p1.x);\r\n  slope = (p2.y - p1.y) / run;\r\n  slope = mix(slope, 1.0, run == 0.0);\r\n  yIntercept = p1.y - p1.x * slope;\r\n  xIntercept = yIntercept / slope;\r\n}\r\n\r\nvoid calcRiseRunIntercept(vec2 p1, vec2 p2, out float rise, out float run, out float xIntercept, out float yIntercept) {\r\n  rise = (p2.y - p1.y);\r\n  run = (p2.x - p1.x);\r\n  float slope = rise / run;\r\n  slope = mix(slope, 1.0, run == 0.0);\r\n  yIntercept = p1.y - p1.x * slope;\r\n  xIntercept = yIntercept / slope;\r\n}\r\n\r\nfloat planePointSlope(vec2 p, vec2 p1, vec2 p2) {\r\n  float slope, xIntercept, yIntercept;\r\n  calcSlopeIntercept(p1, p2, slope, xIntercept, yIntercept);\r\n  float run = p2.x - p1.x;\r\n  float result = p.y - p1.y - slope * p.x + slope * p1.x;\r\n  // result = mix(result, p.x - p1.x, step(run, 0.0));\r\n  if (run == 0.0) result = p1.x - p.x;\r\n  return result;\r\n}\r\n\r\nfloat sdfPlaneStandard(vec2 p, vec2 p1, vec2 p2) {\r\n  float rise, run, slope, xIntercept, yIntercept;\r\n  calcRiseRunIntercept(p1, p2, rise, run, xIntercept, yIntercept);\r\n  return -(run * p.y - rise * p.x - yIntercept);\r\n}\r\n\r\nfloat sdfPlane(vec2 p, vec2 p1, vec2 p2) {\r\n  return cross(p - p1, p2 - p1);\r\n}\r\n\r\nfloat sdfPlaneNorm(vec2 p, vec2 p1, vec2 p2) {\r\n  return cross(p - p1, normalize(p2 - p1));\r\n}\r\n\r\nfloat sdfPlaneDot(vec2 p, vec2 p1, vec2 p2) {\r\n  vec2 normal = (perpRight(p2 - p1));\r\n  return dot(p, normal);\r\n}\r\n\r\nfloat sdfPlaneDotNorm(vec2 p, vec2 p1, vec2 p2) {\r\n  vec2 normal = normalize(perpRight(p2 - p1));\r\n  return dot(p, normal);\r\n}\r\n\r\n// https://stackoverflow.com/questions/21087065/tangent-to-circle-from-external-point-p\r\nvec4 calcTangents(vec2 center, float radius, vec2 p) {\r\n  // Center at origin and make unit circle.\r\n  vec2 n = (p - center) / radius;\r\n  float xy = dot(n, n);\r\n\r\n  // TODO: Equals check with epsilon.\r\n  if (xy == 1.0) return vec4(p.x, p.y, p.x, p.y); // Point on circle, one tangent.\r\n  if (xy \u003c 1.0) return vec4(0.0, 0.0, 0.0, 0.0);  // Point in circle, no tangents.\r\n\r\n  float d = n.y * sqrt(xy - 1.0);\r\n  vec2 t1 = vec2((n.x - d) / xy, 0.0);\r\n  vec2 t2 = vec2((n.x + d) / xy, 0.0);\r\n\r\n  if (n.y != 0.0) {\r\n    t1.y = center.y + radius * (1.0 - t1.x * n.x) / n.y;\r\n    t2.y = center.y + radius * (1.0 - t2.x * n.x) / n.y;\r\n  } else {\r\n    d = radius * sqrt(1.0 - t1.x * t1.x);\r\n    t1.y = center.y + d;\r\n    t2.y = center.y - d;\r\n  }\r\n\r\n  // Recenter and scale.\r\n  return vec4(center.x + radius * t1.x, t1.y, center.x + radius * t2.x, t2.y);\r\n}\r\n\r\nfloat sdfTripleCircle(vec2 p, vec2 pos, float radius, out float headRegion) {\r\n  float radius2 = radius + radius;\r\n  float leftOffsetX = sqrt(radius2 * radius2 - radius * radius);\r\n  float centerOffsetX = (leftOffsetX - radius) * 0.5;\r\n  vec2 topCenter = pos + vec2(0.0, radius);\r\n  vec2 bottomCenter = pos + vec2(0.0, -radius);\r\n  vec4 tangents = calcTangents(topCenter, radius, bottomCenter);\r\n  vec2 b = tangents.xy;\r\n  vec2 c = tangents.zw;\r\n  float tanHeight = c.y - pos.y;\r\n\r\n  float topCircle = sdfCircle(p, topCenter, radius);\r\n  float bottomCircle = sdfCircle(p, bottomCenter, radius);\r\n  float leftCircle = sdfCircle(p, pos + vec2(-leftOffsetX, 0.0), radius);\r\n  float rightRect = sdfRect(p, vec2(c.x, pos.y - c.y), vec2(pos.x, pos.y + c.y));\r\n  float headRect = sdfRect(p, vec2(c.x, pos.y - c.y), vec2(1.0, pos.y + c.y));\r\n  headRegion = sdfDiff(headRect, leftCircle);\r\n  return sdfDiff(rightRect, leftCircle, topCircle, bottomCircle);\r\n  return rightRect;\r\n  return sdfUnion(leftCircle, topCircle, bottomCircle, rightRect);\r\n  return sdfUnion(leftCircle, topCircle, bottomCircle);\r\n}\r\n\r\nfloat sdfTripleCircle2(vec2 p, vec2 pos, float radius, float radius2, float pct, out float headRegion) {\r\n  float hyp = radius + radius2;\r\n  float leftOffsetX = sqrt(hyp * hyp - radius * radius) * pct;\r\n  float centerOffsetX = (leftOffsetX - radius) * 0.5;\r\n  vec2 topCenter = pos + vec2(0.0, radius);\r\n  vec2 bottomCenter = pos + vec2(0.0, -radius);\r\n  vec2 leftCenter = pos + vec2(-leftOffsetX, 0.0);\r\n  vec2 ab = normalize(topCenter - leftCenter);\r\n  vec2 c = leftCenter + ab * radius2;\r\n  float th = c.y - pos.y;\r\n\r\n  float topCircle = sdfCircle(p, topCenter, radius);\r\n  float bottomCircle = sdfCircle(p, bottomCenter, radius);\r\n  float leftCircle = sdfCircle(p, leftCenter, radius2);\r\n  float leftCircle2 = sdfCircle(p, leftCenter, radius2 + 0.01);\r\n  float rightRect = sdfRect(p, vec2(c.x, pos.y - th), vec2(pos.x, pos.y + th));\r\n  float headRect = sdfRect(p, vec2(c.x, pos.y - th), vec2(pos.x + 1.0, pos.y + th));\r\n  headRegion = sdfDiff(headRect, leftCircle2);\r\n  return sdfDiff(rightRect, leftCircle, topCircle, bottomCircle);\r\n  return sdfUnion(leftCircle, topCircle, bottomCircle);\r\n  return rightRect;\r\n  return sdfUnion(leftCircle, topCircle, bottomCircle, rightRect);\r\n}\r\n\r\nfloat sdfVector(vec2 p, QuadParams sp, out float body, out float head) {\r\n  vec2 bottomLeft = vec2(-0.5, -0.5);\r\n  vec2 topRight = vec2(0.5, 0.5);\r\n  float height = sp.strokeWidth / 2.0;\r\n  float headWidth = 0.25;\r\n  float headStart = topRight.x - headWidth;\r\n  float radius = sp.strokeWidth * 1.2;\r\n  vec2 m = vec2(headStart - radius, 0.0);\r\n  vec2 a = vec2(topRight.x, 0.0);\r\n  vec4 tangents = calcTangents(m, radius, a);\r\n  vec2 b = tangents.xy;\r\n  vec2 c = tangents.zw;\r\n  float leftPlane = bottomLeft.x - p.x;\r\n  float rightPlane = b.x - p.x;\r\n  float bodyRightPlane = p.x - headStart;\r\n  float bodyLine = abs(p.y) - height;\r\n  float s1 = cross(a - p, normalize(b - a));\r\n  float s2 = cross(c - p, normalize(a - c));\r\n  float leftCircle = sdfCircle(p, m, radius);\r\n  float bodyLeftCircle = sdfCircle(p, m, radius - sp.aliasWidth);\r\n  body = sdfIntersect(bodyLine, leftPlane, bodyRightPlane);\r\n  // body = sdfDiff(body, sdfDiff(rightPlane, bodyLeftCircle));\r\n  body = sdfDiff(body, sdfDiff(rightPlane, leftCircle));\r\n  head = sdfDiff(rightPlane, leftCircle, s1, s2);\r\n  return sdfUnion(body, head);\r\n}\r\n\r\nfloat sdfVector2(vec2 p, QuadParams sp, out float body, out float head) {\r\n  float height = sp.strokeWidth * 0.5;\r\n  vec2 centerRight = vec2(0.5, 0.0);\r\n  float radius = height * 8.0;\r\n  float headRegion;\r\n  head = sdfTripleCircle2(p, centerRight, radius, radius * 1.5, 0.95, headRegion);\r\n  body = abs(p.y) - height;\r\n  body = sdfDiff(body, headRegion);\r\n  return sdfUnion(body, head);\r\n}\r\n\r\nvec4 fill(vec2 p, float distance, vec4 fillColor, float antialias) {\r\n  float len = length(p);\r\n  float aliasWidth = fwidth(len) * 2.0;\r\n  aliasWidth = fwidth(len);\r\n  aliasWidth = mix(aliasWidth, 0.0, step(antialias, 0.0));\r\n  float edgeDist = 0.0;\r\n  float pct = smoothstep(edgeDist, aliasWidth, distance);\r\n  pct = smoothstep(edgeDist - aliasWidth, edgeDist + aliasWidth, distance);\r\n  vec4 edgeColor = mix(fillColor, transparent, pct);\r\n  // edgeColor = mix(fillColor, vec4(0.3, 0.3, 0.3, 0.4), pct);\r\n  vec4 color = fillColor;\r\n  // color = mix(color, edgeColor, step(edgeDist, distance));\r\n  color = mix(color, edgeColor, step(edgeDist - aliasWidth, distance));\r\n  // color = mix(color, transparent, step(edgeDist + aliasWidth, distance));\r\n  color = mix(color, transparent, step(0.0, distance) * step(aliasWidth, 0.0));\r\n  return color;\r\n}\r\n\r\nvec4 border(vec2 p, float distance, vec4 fillColor, vec4 strokeColor, float strokeWidth) {\r\n  float len = length(p);\r\n  float aliasWidth = fwidth(len) * 2.0;\r\n  float edgeDist = 0.0;\r\n  float strokeDist = edgeDist - strokeWidth;\r\n  float innerEdgeDist = strokeDist - aliasWidth;\r\n  float pct = smoothstep(edgeDist, aliasWidth, distance);\r\n  vec4 edgeColor = mix(strokeColor, transparent, pct);\r\n  edgeColor = mix(strokeColor, vec4(0.3, 0.3, 0.3, 0.4), pct);\r\n  pct = smoothstep(innerEdgeDist, strokeDist, distance);\r\n  vec4 innerEdgeColor = mix(fillColor, strokeColor, pct);\r\n  vec4 color = fillColor;\r\n  color = mix(color, innerEdgeColor, step(innerEdgeDist, distance));\r\n  color = mix(color, strokeColor, step(strokeDist, distance));\r\n  color = mix(color, edgeColor, step(edgeDist, distance));\r\n  return color;\r\n}\r\n\r\nfloat sdfGrid(vec2 p, QuadParams sp, out float axes, out float major, out float minor) {\r\n  float axisWidth = 0.03 * 0.5;\r\n  float majorWidth = 0.02 * 0.5;\r\n  float minorWidth = 0.01 * 0.5;\r\n  float mjdist = 0.1;\r\n  float mndist = mjdist * 0.5;\r\n  float xMid = abs(p.y);\r\n  float yMid = abs(p.x);\r\n  float xAxis = xMid - axisWidth * 0.5;\r\n  float xMajor = abs(fract(xMid / mjdist)) * mjdist - majorWidth;\r\n  float xMinor = abs(fract(xMid / mndist)) * mndist - minorWidth;\r\n  float yAxis = yMid - axisWidth * 0.5;\r\n  float yMajor = abs(fract(yMid / mjdist)) * mjdist - majorWidth;\r\n  float yMinor = abs(fract(yMid / mndist)) * mndist - minorWidth;\r\n  axes = min(xMid - axisWidth, yMid - axisWidth);\r\n  major = sdfUnion(xMajor, yMajor);\r\n  major = sdfDiff(major, axes);\r\n  minor = sdfUnion(xMinor, yMinor);\r\n  minor = sdfDiff(minor, axes, major);\r\n  return sdfUnion(axes, major, minor);\r\n}\r\n\r\nfloat sdfGrid2(vec2 p, QuadParams sp, out float axes, out float major, out float minor) {\r\n  float axisWidth = 0.03 * 0.5;\r\n  float majorWidth = 0.02 * 0.5;\r\n  float minorWidth = 0.01 * 0.5;\r\n  float mjw = majorWidth;\r\n  float mnw = minorWidth;\r\n  float mjdist = 0.1;\r\n  float mndist = mjdist * 0.5;\r\n  float xMid = abs(p.y);\r\n  float yMid = abs(p.x);\r\n  float major1 = abs(fract(min(xMid - mjw, yMid - mjw) / mjdist)) * mjdist - mjw;\r\n  float major2 = abs(fract(max(xMid - mjw, yMid - mjw) / mjdist)) * mjdist - mjw;\r\n  float minor1 = abs(fract(min(xMid - mnw, yMid - mnw) / mndist)) * mndist - mnw;\r\n  float minor2 = abs(fract(max(xMid - mnw, yMid - mnw) / mndist)) * mndist - mnw;\r\n  axes = min(xMid - axisWidth, yMid - axisWidth);\r\n  major = sdfUnion(major1, major2);\r\n  major = sdfDiff(major, axes);\r\n  minor = sdfUnion(minor1, minor2);\r\n  minor = sdfDiff(minor, axes, major);\r\n  return sdfUnion(axes, major, minor);\r\n}\r\n\r\nfloat sdfLines(vec2 p, QuadParams sp) {\r\n  vec2 p1 = vec2(0.0, 0.0);\r\n  vec2 p2 = vec2(0.5, 0.0);\r\n  float angle = fract(time * 2.0 * 0.04) * TWO_PI;\r\n  vec2 rot = vec2(cos(angle), sin(angle));\r\n  p2 = rotate(p2, rot);\r\n  vec4 temp = vec4(p1, p2);\r\n  // p1 = temp.zw; p2 = temp.xy;\r\n  vec2 norm = normalize(perpRight(p2 - p1));\r\n  float radius = 0.25;\r\n  vec2 c1 = norm * radius;\r\n  float l1;\r\n  // l1 = planePointSlope(p, p1, p2);\r\n  // l1 = sdfPlaneStandard(p, p1, p2);\r\n  l1 = sdfPlane(p, p1, p2);\r\n  l1 = sdfPlaneNorm(p, p1, p2);\r\n  // l1 = sdfPlaneDot(p, p1, p2);\r\n  // l1 = sdfPlaneDotNorm(p, p1, p2);\r\n  float l2 = abs(sdfPlaneNorm(p, c1, p2));\r\n  return sdfUnion(l1, l2, sdfCircle(p, c1, radius));\r\n}\r\n\r\nfloat sdfLerpX(vec2 p, float d1, float d2, float x1, float x2) {\r\n  float w = x2 - x1;\r\n  float t = p.x / w;\r\n  t = t * t * t;\r\n  t = 0.7;\r\n  return mix(d1, d2, t);\r\n}\r\n\r\nfloat sdfTemp(vec2 p, QuadParams sp, out float shape1, out float shape2) {\r\n  float height = sp.strokeWidth * 0.5;\r\n  vec2 centerRight = vec2(0.5, 0.0);\r\n  vec2 p1 = vec2(-0.25, -0.25);\r\n  vec2 p2 = vec2(0.25, 0.25);\r\n  vec2 p3 = vec2(0.4, 0.0);\r\n  p3 = centerRight + vec2(-0.365, 0.0);\r\n  vec2 c1 = (p1 + p2) * 0.5;\r\n  vec2 c2 = vec2(0.05, 0.0);\r\n  // c2 = centerRight;\r\n  float r1 = height * 5.5;\r\n  float s1 = sdfRect(p, p1, p2);\r\n  float circle = sdfCircle(p, c2, r1);\r\n  float l1 = centerRight.x - 0.35 - p.x;\r\n  float l2 = sdfPlaneNorm(p, p3, vec2(c2.x,   height * 0.005));\r\n  float l3 = -sdfPlaneNorm(p, p3, vec2(c2.x, -height * 0.005));\r\n  float s2 = sdfIntersect(l1, l2, l3);\r\n  float bodyLine = abs(p.y) - height;\r\n  // bodyLine = sdfIntersect(bodyLine, -l1);\r\n  float head = sdfLerpX(p, circle, s2, c2.x, centerRight.x);\r\n  float headRegion;\r\n  float tc;\r\n  // tc = sdfTripleCircle(p, centerRight, height * 8.0, headRegion);\r\n  float radius = height * 8.0;\r\n  tc = sdfTripleCircle2(p, centerRight, radius, radius * 1.5, 0.95, headRegion);\r\n  bodyLine = sdfDiff(bodyLine, headRegion);\r\n  shape1 = bodyLine;\r\n  shape2 = tc;\r\n  // shape1 = 10.0;\r\n  return sdfUnion(shape1, shape2);\r\n  return tc;\r\n  return sdfLerpX(p, circle, s2, c2.x, centerRight.x);\r\n  return s2;\r\n  return sdfLerpX(p, s1, circle, c2.x, c1.x);\r\n  return sdfLerpX(p, s1, circle, c1.x, c2.x);\r\n  return sdfUnion(s1, circle);\r\n}\r\n\r\nfloat easeInQuad(float t) { return t * t; }\r\nfloat easeInCubic(float t) { return t * t * t; }\r\nfloat easeInQuartic(float t) { return t * t * t * t; }\r\nfloat easeOutQuad(float t) { t = 1.0 - t; return 1.0 - (t * t); }\r\nfloat easeOutCubic(float t) { t = 1.0 - t; return 1.0 - (t * t * t); }\r\nfloat easeOutQuartic(float t) { t = 1.0 - t; return 1.0 - (t * t * t * t); }\r\n\r\nfloat easeInBack(float t) {\r\n  const float s = 1.70158;\r\n  return t * t * ((s + 1.0) * t - s);\r\n}\r\n\r\nfloat easeInElastic(float t) {\r\n    return t == 0.0 ? 0.0\r\n      : t == 1.0 ? 1.0\r\n      : (0.04 - 0.04 / t) * sin(25.0 * t) + 1.0;\r\n}\r\n\r\nfloat sdfDistToLerpSegment(vec2 p, vec2 a, vec2 b, float dist, float t, float tx, float ty) {\r\n  if (t \u003c= 0.0) return dist;\r\n  if (t \u003e= 1.0) return dist;\r\n\r\n  vec2 normal = perp(b - a);\r\n  normal = normalize(normal);\r\n  a = vec2(mix(a.x, b.x, tx), mix(a.y, b.y, ty));\r\n  float d = dot(normal, a);\r\n  return dot(normal, p) - d;\r\n}\r\n\r\nfloat calcLerpOffset(vec2 a, vec2 b, float t, float tx, float ty) {\r\n  float len = length(b - a);\r\n  vec2 dir = vec2(1.0, 1.0);\r\n  vec2 normal = perpRight(dir);\r\n  normal = normalize(normal);\r\n  vec2 cd = dir * len;\r\n  vec2 p = dir * t;\r\n  vec2 pp = vec2(mix(0.0, cd.x, tx), mix(0.0, cd.y, ty));\r\n  vec2 ofs = pp - p;\r\n  float result = dot(ofs, normal);\r\n  return result;\r\n}\r\n\r\nfloat sdfDistToLerpSegmentA(vec2 p, vec2 a, vec2 b, float dist, float t, float tx, float ty) {\r\n  if (t \u003c= 0.0) return dist;\r\n  if (t \u003e= 1.0) return dist;\r\n\r\n  vec2 normal = perp(b - a);\r\n  normal = normalize(normal);\r\n  float offset = calcLerpOffset(a, b, t, tx, ty);\r\n  a = a + (b - a) * t;\r\n  a = a + normal * offset;\r\n\r\n  float d = dot(normal, a);\r\n  return dot(normal, p) - d;\r\n}\r\n\r\nfloat sdfVector3(vec2 p, QuadParams sp, out float body, out float head) {\r\n  float height = sp.strokeWidth * 0.5;\r\n  vec2 m = vec2(sp.topRight.x, 0.0);\r\n  vec2 p1 = vec2(sp.topRight.x - height * 12.0,  height * 13.0);\r\n  vec2 p2 = vec2(sp.topRight.x - height * 12.0, -height * 13.0);\r\n  float t;\r\n  float l1 = signedDistToSegment(p, p1, m, t);\r\n  l1 = sdfDistToLerpSegment(p, p1, m, l1, t, t, easeOutCubic(t));\r\n  float l2 = signedDistToSegment(p, m, p2, t);\r\n  l2 = sdfDistToLerpSegment(p, m, p2, l2, t, t, easeInCubic(t));\r\n  float l3 = signedDistToSegment(p, p1, p2, t);\r\n  l3 = sdfDistToLerpSegmentA(p, p2, p1, l3, t, easeInQuad(t), t);\r\n  body = abs(p.y) - height;\r\n  head = sdfIntersect(l1, l2, l3);\r\n  body = sdfDiff(body, (sp.topRight.x + p1.x) * 0.5 - p.x);\r\n  return sdfUnion(body, head);\r\n}\r\n\r\n// TODO: Fix.\r\nfloat sdfBezierSegment(vec2 p, vec2 a, vec2 b, vec2 c) {\r\n  float t;\r\n  float dist = signedDistToSegment(p, a, b, t);\r\n\r\n  float t1 = 1.0 - t;\r\n  vec2 pp = t1 * t1 * a + 2.0 * t1 * t * c + t * t * b;\r\n\r\n  vec2 normal = perp(b - a);\r\n  normal = normalize(normal);\r\n  float d = dot(pp, normal);\r\n  float result = (dot(p, normal) - d);\r\n  // float result = (dot(p, normal) - d) / dot(normal, normal);\r\n  result = mix(result, dist, step(t, 0.0));\r\n  result = mix(result, dist, step(1.0, t));\r\n  return result;\r\n}\r\n\r\nfloat sdfDistToLerpSegmentB(vec2 p, vec2 a, vec2 b, float dist, float t, float tx) {\r\n  vec2 ab = b - a;\r\n  vec2 normal = perp(ab);\r\n  vec2 mid = (a + b) * 0.5;\r\n  vec2 e = a + ab * t;\r\n  vec2 pp;\r\n  // t = tx;\r\n\r\n  if (t \u003c 0.5) {\r\n    vec2 c = mid + normal;\r\n    t = t * 2.0;\r\n    float t1 = 1.0 - t;\r\n    pp = t1 * t1 * a + 2.0 * t1 * t * c + t * t * b;\r\n  } else {\r\n    vec2 c = mid + -normal;\r\n    t = (1.0 - t) * 2.0;\r\n    float t1 = 1.0 - t;\r\n    pp = t1 * t1 * a + 2.0 * t1 * t * c + t * t * b;\r\n  }\r\n\r\n  normal = normalize(normal);\r\n  float d = dot(pp, normal);\r\n  float result = (dot(p, normal) - d);\r\n  // float result = (dot(p, normal) - d) / dot(normal, normal);\r\n  result = mix(result, dist, step(t, 0.0));\r\n  result = mix(result, dist, step(1.0, t));\r\n  return result;\r\n}\r\n\r\nfloat sdfBezierSegment(vec2 p, QuadParams sp) {\r\n  float height = sp.strokeWidth * 0.5;\r\n  vec2 m = vec2(sp.topRight.x, 0.0);\r\n  vec2 p1 = vec2(0.0,  0.0);\r\n  vec2 p2 = vec2(0.0, -0.4);\r\n  vec2 p3 = vec2(0.25, (p1.y + p2.y) * 0.01);\r\n  p3 = vec2(0.3, 0.01);\r\n  // p3 = perp(p2 - p1) * 0.5;\r\n  float angle = fract(time * 2.0 * 0.04) * TWO_PI;\r\n  vec2 rot = vec2(cos(angle), sin(angle));\r\n  // p2 = rotate(p2, rot);\r\n  // p3 = rotate(p3, rot);\r\n  float t;\r\n  float l1 = signedDistToSegment(p, p1, m, t);\r\n  l1 = sdfDistToLerpSegment(p, p1, m, l1, t, t, easeOutCubic(t));\r\n  float l2 = signedDistToSegment(p, m, p2, t);\r\n  l2 = sdfDistToLerpSegment(p, m, p2, l2, t, t, easeInCubic(t));\r\n  float l3 = sdfBezierSegment(p, p2, p1, p3);\r\n  l3 = signedDistToSegment(p, p2, p1, t);\r\n  l3 = sdfDistToLerpSegmentB(p, p2, p1, l3, t, easeInQuad(t));\r\n  // l3 = sdfDistToLerpSegmentA(p, p2, p1, l3, t, smoothstep(0.0, 1.0, t), t);\r\n  // l3 = sdfDistToLerpSegmentA(p, p2, p1, l3, t, t, smoothstep(0.0, 1.0, t));\r\n  float bodyLine = abs(p.y) - height;\r\n  float tip = sdfIntersect(l1, l2, l3);\r\n  bodyLine = sdfDiff(bodyLine, (sp.topRight.x + p1.x) * 0.5 - p.x);\r\n  return l3;\r\n  float head = tip;\r\n  return sdfUnion(bodyLine, head);\r\n}\r\n\r\nvoid main() {\r\n  QuadParams sp = sdfToLocal1(v_params);\r\n  vec2 p = sdfPointToLocal1(gl_FragCoord.xy, sp);\r\n\r\n  float body;\r\n  float head;\r\n  float vec = sdfVector(p, sp, body, head);\r\n  vec = sdfVector2(p, sp, body, head);\r\n  vec = sdfVector3(p, sp, body, head);\r\n\r\n  vec4 color;\r\n  float antialias = 1.0;\r\n  vec4 fillColor = mix(sp.strokeColor, sp.fillColor, step(head, body));\r\n  fillColor = mix(fillColor, sp.fillColor, step(head, 0.0));\r\n  color = fill(p, vec, fillColor, antialias);\r\n  // color = border(p, dist, sp.fillColor, sp.strokeColor, 0.01);\r\n\r\n  float axes;\r\n  float major;\r\n  float minor;\r\n  float dist = sdfGrid(p, sp, axes, major, minor);\r\n  // dist = sdfGrid2(p, sp, axes, major, minor);\r\n  fillColor = sp.fillColor;\r\n  fillColor = transparent;\r\n  fillColor = mix(fillColor, sp.fillColor, float(axes \u003c= 0.0));\r\n  fillColor = mix(fillColor, sp.strokeColor, float(major \u003c= 0.0));\r\n  fillColor = mix(fillColor, vec4(0.1, 0.1, 0.1, 1.0), float(minor \u003c= 0.0));\r\n  // color = fill(p, dist, fillColor, 1.0);\r\n  // color = fill(p, dist, sp.fillColor, 1.0);\r\n\r\n  dist = sdfLines(p, sp);\r\n  // color = fill(p, dist, sp.fillColor, 1.0);\r\n  // color = border(p, dist, sp.fillColor, sp.strokeColor, sp.strokeWidth);\r\n\r\n  float s1;\r\n  float s2;\r\n  dist = sdfTemp(p, sp, s1, s2);\r\n  float intersect = sdfIntersect(s1, s2);\r\n  fillColor = mix(sp.strokeColor, sp.fillColor, step(s2, s1));\r\n  fillColor = mix(fillColor, sp.fillColor, step(intersect, 0.0));\r\n  // color = fill(p, dist, fillColor, 1.0);\r\n\r\n  dist = sdfBezierSegment(p, sp);\r\n  // color = fill(p, dist, sp.strokeColor, 1.0);\r\n\r\n  glFragColor = color;\r\n}"]]));

